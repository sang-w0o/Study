# 3. 모듈성

> 소프트웨어 아키텍쳐 용어의 95%는 '모듈성'의 이로움을 찬양하는 데 사용되고 있지만, 정작 모듈성을 어떻게 달성할지에 대해서는 별다른 얘기가 없다.

- 당연하겠지만 모듈성은 사실 제대로 정의하기가 쉽지 않은 개념이다.

- 모듈성은 일종의 구성 원리(organizing principle)이다.

---

## 3.1 정의

- 모듈의 사전적 정의는 '복잡한 구조를 만드는 데 쓰이는 각각의 표준화된 부품이나 독립적인 단위' 이다.  
  개발자들은 모듈성을 이용해 객체 지향 언어의 class나 함수형 언어의 함수가 될만한 서로 연관된 코드를 논리적으로 묶는다.  
  프로그래밍 언어의 대부분은 모듈성 메커니즘을 제공하며, 개발자는 보통 연관된 코드를 함께 묶는 수단으로 모듈을 사용한다.

- 아키텍트는 개발자가 코드를 어떻게 패키징하는지 반드시 알아야하는데, 그 이유는 아키텍쳐에 중요한 영향을 미치기 때문이다.  
  여러 패키지가 서로 단단히 커플링되어 있으면, 그 중 하나를 다른 작업에 재사용하기가 매우 어려워진다.

- 일반적으로 아키텍쳐를 논할 때 클래스, 함수 처럼 코드를 묶어 놓은 덩어리를 모듈성이라는 일반 용어로 나타낸다.  
  이는 논리적인 구분이지 물리적 구분은 아닌데, 이 차이점은 굉장히 중요할 때가 있다.  
  예를 들어, 모놀리식 애플리케이션은 편의상 꽤 많은 클래스를 한 덩이로 묶어도 크게 상관이 없지만, 아키텍쳐를 재구축할 때는 이렇게  
  커플링된 구조가 모놀리스를 나누는 데 걸림돌이 된다. 따라서 모듈성은 특정 플랫폼에 함축되어있거나 불가피한 물리적인 분리와는  
  다른 개념으로 바라보는게 좋다.

---

## 3.2 모듈성 측정

### 3.2.1 응집(cohesion)

- 응집은 한 모듈의 파트(구성 요소)가 동일한 모듈 안에 얼마나 포함되어 있는지를 나타낸다. 다시 말해, 모듈을 구성하는 파트가 서로 얼마나  
  연관되어 있는지를 의미한다. 이상적으로 응집된 모듈이라면 모든 파트가 함께 패키징되어 있을 것이다. 파트를 더 잘게 쪼개려면  
  모듈 간 호출을 통해 파트를 묶어야 유용한 결과를 얻을 수 있기 때문이다.

> 응집된 모듈을 나누려고 해봐야 더 커플링되고 가독성은 떨어진다.

- 아래는 컴퓨터 과학자들이 정의한 응집도의 측정 범위이고, 가장 좋은 것부터 나쁜 것 순으로 나열한 것이다.

- **기능적 응집(functional cohesion)**: 모듈의 각 파트는 다른 파트와 연관되어 있고, 기능상 꼭 필요한 것이 모듈에 들어있다.
- **순차적 응집(sequential cohesion)**: 두 모듈이, 한쪽이 데이터를 출력하면 다른 한쪽이 그것을 입력 받는 형태로 상호작용한다.
- **소통적 응집(communicational cohesion)**: 두 모듈이, 각자 정보에 따라 작동하고 어떤 출력을 내는 형태로 통신 체인을 형성한다.  
  예를 들어, DB에 레코드를 추가하면 그 정보에 따라 이메일이 만들어지는 형태이다.
- **절차적 응집(procedural coheison)**: 두 모듈이 정해진 순서대로 실행되어야 한다.
- **일시적 응집(temporal cohesion)**: 모듈이 시점 의존성(timing dependency)에 따라 연관된다. 예를 들어, 많은 시스템들이 시작될 때  
  그다지 관련이 없어 보이는 것들을 쭈욱 초기화하는 경우가 많은데, 이런 작업들이 일시적으로 응집되었다고 할 수 있다.
- **논리적 응집(logical cohesion)**: 모듈의 내부 데이터가 기능적이 아니라, 논리적으로 연관되어 있다. 텍스트, 직렬화 객체, 스트림 형태로  
  받은 데이터를 변환하는 모듈들이 그렇다. 서로 연관된 작업들이지만 하는 일은 전혀 다르다. 이런 종류의 응집이 좋은 예시로는 거의 모든 Java  
  프로젝트에서 사용되는 `StringUtils` 패키지에서 찾아볼 수 있는데, 이 패키지에는 각기 다른 작업을 수행하는 정적 메소드들이 많이 있지만  
  서로 연관성은 없다.
- **동시적 응집(coincidental cohesion)**: 같은 소스 파일에 모듈 구성 요소가 들어있지만, 그 외에는 아무 연관성도 없다.  
  이것이 가장 좋지 않은 형태의 응집이다.

- 응집은 커플링보다는 덜 정확한 메트릭이므로 아키텍트의 재량에 따라 측정된 모듈의 응집도는 다르다.  
  하지만 응집도를 측정하는 한 가지 방법을 보자.

- LCOM(Lack Of Cohesion of Methods)는 모듈(보통 컴포넌트)의 구조적 응집도를 나타낸다.  
  식을 말로 풀이하면, '공유 필드를 통해 공유되지 않는 메소드의 총 개수` 를 의미한다.

  - 예를 들어, private field a, b가 있는 클래스가 있다고 해보자. 이 클래스는 a만 접근하는 메소드가 있고, b만 접근하는  
    메소드도 있다. 공유 필드(a, b)를 톨해 공유되지 않는 메소드는 많기 때문에 이 클래스의 LCOM 점수는 높다.
  - LCOM 점수가 낮을 수록 응집도가 높고, LCOM 점수가 높을 수록 응집도가 낮다.
  - LCOM 메트릭은 아키텍쳐 스타일을 전환하기 위해 코드베이스를 분석하는 아키텍트에게 매우 유용하다.
  - 하지만 LCOM도 만능은 아닌게, '구조적' 응집 결여도만을 찾아내기 때문이다.

### 3.2.2 커플링

- 커플링을 측정하는 다양한 방식이 있는데, 이 중 세개만 보자.

  - 추상도
  - 불안정도
  - 메인 시퀀스로부터의 거리

### 3.2.3 커네이선스(connascence)

> 두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면, 이들은 커네이선스를 갖고 있는 것이다.

#### 정적 커네이선스

- (런타임 커플링과 정반대인) 소스 코드 레벨의 커플링으로, 구심/원심 커플링을 발전시킨 개념이다.  
  아키텍트는 구심적이든 원심적이든 다음 종류의 정적 커네이선스를 뭔가에 커플링된 정도라고 보는 것이다.

- **명칭 커네이선스(CoN)**: 여러 컴포넌트의 엔티티명이 일치해야 한다. 메소드명은 코드베이스가 커플링되는 가장 일반적이면서 바람직안 방법이다.
- **타입 커네이선스(CoT)**: 여러 컴포넌트의 엔티티 타입이 일치해야 한다. 대부분의 정적 타입 언어에서 변수와 매개변수를 특절 타입으로  
  제한하는 일반적인 기능이다. 하지만 이는 언어 자체에 내장된 기능은 아닌데, closure, closure spec 등 선택적 타이핑 기능을  
  제공하는 동적 타입 언어들도 있다.
- **의미 커네이선스(CoM) 또는 관례 커네이선스(CoC)**: 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 한다. 이런 종류의 커네이선스는  
  상수 대신 숫자를 하드코딩한 코드베이스에서 흔히 발견되는데, 예를 들어 `int TRUE = 1; int FALSE = 0;`처럼 말이다.  
  누군가 이 값을 바꿔놓는다면, 그 결과가 얼마나 끔찍할까?
- **위치 커네이선스(CoP)**: 여러 컴포넌트는 값의 순서가 일치해야 한다. 정적 타이핑이 가능한 언어에서도 메소드와 함수 호출 시  
  전달하는 매개변수 값은 순서가 맞아야 한다. 예를 들어, 개발자가 `void updateSeat(String name, String seatLocation)`라는  
  메소드를 만들고, `updateSeat("14D", "Ford, N")`로 호출하면 매개변수 타입은 맞지만 의미는 맞지 않게 된다.

- **알고리즘 커네이선스(CoA)**: 여러 컴포넌트는 특정 알고리즘이 일치해야 한다. 흔한 예시로, 서버/클라이언트 모두 실행되어야 하고  
  유저 인증 시 반드시 동일한 결과를 내야하는 보안 해시 알고리즘이 그렇다. 두말할 나위도 없이 이는 아주 커플링이 심하다는 증거이다.  
  두 알고리즘 중 하나라도 로직이 바뀌면 더 이상 handshake는 이루어지지 않을 것이다.

#### 동적 커네이선스

- 동적 커네이선스는 런타임 호출을 분석하는 또다른 유형의 커네이선스이다.

- **시점 커네이선스(CoT)**: 여러 컴포넌트의 실행 시점이 중요하다. 시점 커네이선스의 가장 일반적인 사례는 동시에 실행 중인 두  
  스레드 때문에 race condition이 발생해 공동 작업의 결과에 영향을 끼치는 것이다.
- **값 커네이선스(CoV)**: 상호 연관된 다수의 값들을 함께 변경할 때 발생한다. 트랜잭션을 예시로 보자. 데이터베이스가 각각 분리된  
  시스템을 설계했는데, 모든 데이터베이스에서 하나의 값을 업데이트해야 할 경우, 전체 값들을 한 번에 바꾸든지, 아무 값도 바꾸지  
  말든지 해야 한다.
- **식별 커네이선스(CoL)**: 여러 컴포넌트가 동일한 엔티티를 참조할 때 발생한다. 가장 대표적인 사례로, 독립적인 두 컴포넌트가  
  분산 큐 같은 자료 구조를 공유해서 업데이트하는 경우가 있다.

#### 커네이선스 속성

- 커네이선스는 아키텍트와 개발자에게 유용한 분석 도구로, 아래 프로퍼티들을 잘 활용하면 큰 도움이 된다.

- **강도**: 아키텍트는 개발자가 어떤 유형의 커네이선스를 얼마나 쉽게 리팩토링할 수 있는지에 따라 커네이선스 강도를 결정한다.  
  아키텍트와 개발자는 더 나은 유형의 커네이선스를 리팩토링해 코드베이스의 커플링 특성을 개선할 수 있다.

  - 정적 커네이선스는 개발자가 IDE를 활용하거나 코드 분석으로 어렵지 않게 개선할 수 있다.
  - 커네이선스 강도는 리팩토링을 안내하는 충실한 표지판으로, 어려운 것부터 쉬운 것까지의 순서는 아래와 같다.
    - 아이덴티티 -> 값 -> 타이밍 -> 실행 -> 위치 -> 알고리즘 -> 의미 -> 타입 -> 명칭

- **지역성**: 커네이선스의 지역성(locality)는 코드베이스의 모듈들이 서로 얼마나 가까이 있는지를 나타낸다.  
  동일한 모듈에서 근접한 코드는 보통 더 분리된 코드보다 높은 형태의 커네이선스를 가진다. 즉, 모듈을 서로 떨어뜨렸을 때  
  커플링이 형편없는 형태의 커네이선스는 모듈을 서로 가까이 붙여놓는 식으로 개선할 수 있다. 동일한 모듈에서 더 강한 형태의  
  커네이선스가 발견된다면, 그와 동일한 커네이선스가 널리 흩어져 있는 것 보다는 code smell이 덜하다는 증거이다.

- **정도**: 커네이선스 정도(degree)는 커네이선스가 미치는 영향의 규모에 관한 것이다. 이 값이 작을수록 코드베이스 입장에서는  
  바람직하다. 모듈이 몇 개 안된다면 동적 커네이선스가 높아도 별로 해롭지 않지만, 일반적으로 코드베이스는 점점 커지기 마련이니  
  사소한 문제도 점점 더 악화될 것이다.

- 커네이선스를 이용해 시스템 모듈성을 개선하는 세 가지 방식을 보자.

  - 1. 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이선스를 최소화한다.
  - 2. 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화한다.
  - 3. 캡슐화 경계 내부에서 커네이선스를 최대화한다.

> - 정도의 규칙: 강한 형태의 커네이선스를 보다 약한 커네이선스로 전환하라.
> - 지역성의 규칙: 소프트웨어 엘리먼트 간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 활용하라.

### 3.2.4 1990년대 커네이선스의 문제점

- 아키텍트가 커네이선스를 적용해 시스템을 분석, 설계할 때 몇 가지 문제점들이 있다.
- 먼저, 커네이선스는 아키텍쳐 구조보다는 저수준 코드의 세부분을, 코드 품질 및 정리 상태 위주로 관리한다.  
  아키텍트 입장에서는 커플링의 정도보다 모듈이 어떻게 커플링되어 있는지가 더 궁금하기 마련이다.  
  예를 들어, 아키텍트는 동기 통신이냐 비동기 통신이냐를 고민하지, 이를 어떻게 구현할지는 별로 관심이 없다.

- 다음으로, 사실 커네이선스 자체는 요즘 아키텍트가 내려야할 (MSA 같은 분산 아키텍쳐에서의 동기 통신이냐 비동기 통신이냐) 근본적인  
  결정에 대한 문제는 다루지 않는다.

---

## 3.3 모듈에서 컴포넌트로

- 여기서는 연관된 코드의 묶음을 '모듈' 이라는 일반 용어로 표현하지만, 대부분의 플랫폼은 소프트웨어 아키텍트에게 핵심 구성요소 중 하`나인 '컴포넌트' 형태로 지원한다.

---

---
