# 6. 아키텍쳐 특성의 측정 및 거버넌스

- 보다 일반적인 아키텍쳐 특성을 구체적으로 정의하고, 거버넌스 메커니즘을 구축하는 방법을 살펴보자.

## 6.1 아키텍쳐 특성 측정

- 아키텍쳐 특성을 정의할 땐 흔히 아래의 문제들이 발생한다.

  - 아키텍쳐 특성은 대부분 의미가 모호하다.
  - 정의가 너무 다양하다.
  - 너무 복합적이다.

- 위 세 문제는 아키텍쳐 특성을 객관적으로 정의하면 모두 해결된다.

### 6.1.1 운영적 측정

- 아키텍쳐 특성은 성능, 확장성 처럼 비교적 정확히 측정할 수 있는 것도 많지만, 팀 목표에 따라 그에 따른 해석은 미묘하게  
  갈리는 경우가 많다. 예를 들어, 특정 요청에 대한 평균 응답 시간을 측정할 경우, 어떤 경계 조건 때문에 1%의 요청이  
  다른 요청보다 처리 시간이 10배나 오래 걸리면 어떻게 해야 할까?

- 달성하기 어려운 성능 수치를 정하는 대신, 통계 분석 결과로 얻은 나름대로의 정의에 기반할 수 있다.  
  예를 들어, 확장성을 모니터링하는 비디오 스트리밍 서비스 업체의 경우, 엔지니어는 아무 수치나 대충 목표로 잡는게 아니라  
  시간에 따라 어떤 추이를 보이는지 측정하고, 통계 모델을 수립한다. 그리고 실시간 수집된 메트릭이 예측 모델에서 벗어난  
  경우 알림 메시지를 보낸다.

- 애플리케이션이 실행되는 기기, 목표, 능력, 기타 다른 많은 것들이 변할수록 팀은 새로운 것을 발견하고 그것을 측정할  
  새로운 방법을 찾게될 것이다.

### 6.1.2 구조적 측정

- 성능처럼 목표치가 확실하지 않은 메트릭도 있다. 잘 정의된 모듈성 처럼 내부 구조에 대한 특성도 그렇다.

- 예를 들어, 코드의 복잡도는 '순환 복잡도'라는 메트릭을 통해 명쾌하게 측정할 수 있다.

> 순환 복잡도는 코드 레벨의 메트릭으로 함수, 클래스, 또는 애플리케이션 레벨에서 코드 복잡도를 객관적으로 나타내는 지표이다.  
>  이 메트릭은 코드에 그래프 이론을 적용해 계산한다. 상이한 실행 경로(execution path)를 유발하는 결정점(decision point)를  
>  이용한다. 예를 들어, 어떤 함수에 if문 같은 결정문(decision statement)이 하나도 없다면 순환 복잡도는 1이고,  
>  조건 분기가 하나 있으면 실행 경로가 두 개로 갈라지므로 2가 된다.
>
> 하나의 함수나 메소드에서 순환 복잡도를 구하는 공식은 `CC = E - N + 2`이다.  
>  여기서 `N`은 node(코드 라인), `E`는 edge(결정문 수) 이다.  
>  아래는 예시 코드이다.
>
> ```java
> public void decision(int c1, int c2) {
>     if (c1 < 100) return 0;
>     else if (c1 + c2 > 500) return -1;
>     else return 1;
> }
> ```
>
> 위 코드의 순환 복잡도는 `5 - 4 + 2 = 3`이다. 식 끝에 있는 2는 단일 함수를 단순화한 값이다.
> 다른 메소드도 호출하는 경우까지 고려한 일반 공식은 `CC = E - N + 2P`(p = 연결된 컴포넌트 수)이다.

### 6.1.3 프로세스 측정

- 소프트웨어 개발 프로세스와 교차하는 아키텍쳐 특성도 있다.  
  예를 들어 민첩성은 바람직한 특성으로 보일 때가 많은데, 이는 시험성, 배포성 등의 특성으로 나눌 수 있는 복합적인 아키텍쳐 특성이다.

- 시험성은 거의 모든 플랫폼에서 코드 커버리지 도구로 측정할 수 있다. 물론 이 메트릭이 만능은 아니지만, 시험성 특성은 분명히  
  객관적으로 측정할 수 있는 특성이다. 마찬가지로 배포성 역시 실패 대비 배포 성공률, 배포 소요시간, 배포 시 발생한 이슈, 버그 등  
  측정 가능하다.

- 민첩성과 이와 관련된 부분은 분명히 소프트웨어 개발 프로세스와 연관이 있지만, 이 프로세스는 아키텍쳐 구조에도 영향을  
  미칠 수 있다. 예를 들어, 배포 용이성과 시험성이 최우선 항목이라면 아키텍트는 아키텍쳐 수준에서 모듈성, 격리성을  
  높이는 데 주력할 것이고, 이는 아키텍쳐 특성이 구조를 주도하는 좋은 예시이다.

---

## 6.2 거버넌스와 피트니스 함수

### 6.2.1 아키텍쳐 특성 관리

- 거버넌스는 아키텍트가 담당하는 중요한 업무로, 아키텍쳐 거버넌스는 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄한다.  
  아키텍쳐 거버넌스의 여러 부분을 자동화하기 위해 사용되는 피르니스 함수라는 기법이 있다.

### 6.2.2 피트니스 함수

- 피트니스 함수는 결과가 목표에 얼마나 근접했는지를 나타내는 목표 함수이다.

#### 아키텍쳐 피트니스 함수

- 아키텍쳐 피트니스 함수는 어떠한 아키텍쳐 특성(혹은 조합)의 객관적인 무결성을 평가하는 모든 메커니즘을 말한다.  
  피트니스 함수는 수많은 기존 도구들을 바라보는 새로운 시각이다. 아키텍쳐 피트니스 함수는 사용하는 방법에 따라 메트릭, 모니터,  
  단위 테스팅 라이브러리, 카오스 엔지니어링 등 기존의 많은 메커니즘과 중첩되는 부분이 있다.

- 흔히 사용되는 아키텍쳐 피트니스 함수의 예시는 아래와 같다.

  - 순환 참조를 감지하는 피트니스 함수
  - 메인 시퀀스로부터의 거리를 측정하는 피트니스 함수
  - 레이어드 아키텍쳐의 패턴을 지키는지 확인하는 피트니스 함수
  - ArchUnit, JDepend, Chaos Monkey, Simian Army 등 피트니스 함수의 구현체

- 아키텍쳐 피트니스 함수들과 구현체를 잘 활용하면 중요한 거버넌스 체크를 아키텍쳐 하부에 구체화할 수 있다.

---
