# 13. 마이크로커널 아키텍쳐 스타일

- 이미 수십 년 전 만들어진 마이크로커널 아키텍쳐 스타일(aka plug-in 아키텍쳐 스타일)은 오늘날에도 널리 쓰인다.  
  이 스타일은 단일 모놀리식 배포 단위로 패키징해서 다운로드 및 설치가 가능하며, 보통 고객 사이트에서 3rd party 제품으로  
  설치되는 제품 기반(product-based) 애플리케이션에 적합하며, 비제품(nonproduct) 고객 비즈니스 애플리케이션에서도 많이 사용된다.

---

## 12.1 Topology

- 마이크로커널 아키텍쳐 스타일은 코어 시스템(core system)과 플러그인 컴포넌트(plug-in component)라는 두 가지의  
  아키텍쳐 요소로 구성된, 비교적 단순한 모놀리식 아키텍쳐이다. 애플리케이션 로직은 독립적인 플러그인 컴포넌트와 기본 코어 시스템에  
  골고루 분산되어 확장성, 적응성, 애플리케이션 기능 분리, 커스텀 처리 등을 수행한다.

### 12.1.1 코어 시스템

- 코어 시스템은 시스템을 실행시키는 데 필요한 최소한의 기능으로 정의한다.  
  IntelliJ IDEA와 같은 IDE를 예시로 들면, IntelliJ의 코어 시스템은 파일을 열고, 텍스트를 수정하고, 다시 파일을 저장하는  
  기본적인 텍스트 편집기에 불과하다. 플러그인을 추가해야 비로소 쓸만한 제품이 된다. 그러나 다른 관점에서 바라보면, 코어 시스템은  
  커스텀한 처리가 거의 또는 전혀 필요 없는 애플리케이션을 관통하는 happy path라고 정의할 수 있다.  
  코어 시스템의 순환 복잡도를 없애고 별도의 플러그인 컴포넌트를 장착하면 확장성, 유지보수성은 물론 시험성도 좋아진다.

- 예를 들어, 어떤 전자제품 재활용 애플리케이션에서 수취한 제품마다 정해진 감정 규칙을 적용한다고 해보자.

```java
public void assessDevice(String deviceID) {
	if (deviceID.equals("iPhone15s")) {
		assessiPhone15s();
	} else if (deviceID.equals("iPad2")) {
		assessiPad2();
	} else if (deviceID.equals("Galaxy12")) {
		assessGalaxy12();
	} else // ..
		// ..
}
```

- 클라이언트에 종속된 코드를 순환 복잡도가 높은 코어 시스템에 두는 대신, 각 전자제품마다 플러그인 컴포넌트를 따로 만들면, 감정하기 훨씬 더  
  효율적일 것이다. 이렇게 개별 클라이언트마다 플러그인 컴포넌트를 만들어 끼우면, 나머지 처리흐름과 무관한 로직을 따로 떼어낼 수 있고, 차후  
  확장도 가능해진다. 감정할 제품이 추가되면, 단지 새로운 플러그인 컴포넌트를 추가하고 레지스트리를 업데이트하면 그만이다.

- 마이크로커널 아키텍쳐에서는 위 코드를, 코어 시스템이 해당 제품의 플러그인을 찾아 호출하는 방식으로 아래처럼 고칠 수 있다.

```java
public void assessDevice(String deviceID) {
	String plugin = pluginRegistry.get(deviceID);
	Class<?> theClass = Class.forName(plugin);
	Constructor<?> constructor = theClass.getConstructor();
	DevicePlugin devicePlugin = (DevicePlugin) constructor.newInstance();
	devicePlugin.assess();
}
```

- 각 전자제품을 감정하는 일체의 복잡한 규칙과 로직을 코어 시스템에서 일반화해 실행 가능한, 독립적인 standalone 플러그인 컴포넌트에 담는 것이다.

- 코어 시스템은 규모와 복잡도에 따라 layered 아키텍쳐나 모듈러 모놀리스로 구현할 수 있다.  
  경우에 따라 코어 시스템을 별도 배포하는 도메인 서비스로 나누어, 서비스별 도메인에 특정한 플러그인 컴포넌트를 둘 수도 있다.  
  예를 들어, `Payment Processing` 이 코어 시스템을 나타내는 도메인이라면, 결제 도메인에 특정한 각 결제 수단(신용카드, 선불카드,  
  기프트카드 등)이 플러그인 컴포넌트가 될 것이다. 어떤 경우에도 모놀리스 애플리케이션은 하나의 DB를 공유하는 것이 보통이다.

  - Layered 코어 시스템: 코어 시스템 내부가 layer들로 구성된 layered 아키텍쳐 스타일을 따른다.
  - 모듈러 코어 시스템: 코어 시스템 내부가 여러 개의 도메인 컴포넌트들로 분리된다.

### 12.1.2 플러그인 컴포넌트

- 플러그인 컴포넌트는 특수한 처리 로직, 부가 기능, 그리고 코어 시스템을 개선 및 확장하기 위한 커스텀 코드가 구현된 standalone 컴포넌트이다.  
  변동성이 매우 큰 코드를 분리해 애플리케이션 내부의 유지보수성, 시험성을 높이는 것이다. 이상적인 플러그인 컴포넌트는 상호 독립적이며,  
  의존성이 없다.

- 플러그인 컴포넌트와 코어 시스템은 일반적으로 점대점(point-to-point) 통신을 한다.  
  즉, 코어 시스템에 플러그인을 연결하는 '파이프'는 대부분 플러그인 컴포넌트의 진입점 클래스(entrypoint class)를 호출하는  
  메소드나 함수 코드이다.

- 플러그인 컴포넌트는 컴파일 기반 또는 런타임 기반으로 만들 수 있다.  
  런타임 플러그인 컴포넌트는 런타임에 코어 시스템이나 다른 플러그인을 재배포하지 않고도 추가, 삭제가 가능하며, Java로 예를 들면  
  OSGi(Open Service Gateway Initiative)와 같은 프레임워크를 통해 관리한다.  
  컴파일 기반의 플러그인 컴포넌트는 관리하기는 편하지만 변경, 추가, 삭제 시 전체 모놀리식 애플리케이션을 재배포해야 한다.

- 점대점 플러그인 컴포넌트는 JAR, DLL, Gem과 같은 공유 라이브러리, 패키지명(Java), namespace(C#) 로 구현할 수 있다.  
  위에서 본 전자제품 재활용 애플리케이션을 예로 들면, 각 전자제품 플러그인은 JAR, DLL, Gam으로 작성하고, 각 제품명과  
  동일한 독립적인 공유 라이브러리 명칭을 사용하면 된다.

- 플러그인 컴포넌트가 반드시 코어 시스템과 점대점 통신을 해야만 하는 것은 아니다. 각 플러그인을 standalone 서비스로 만들어  
  REST나 메시징 등 다른 방법으로 기능을 호출하는 방법도 있다. 이는 언뜻 보기에 전체 확장성을 개선하는 좋은 방법 같지만,  
  이 topology는 코어 시스템이 모놀리식이므로 여전히 단일 아키텍쳐 퀀텀이다. 즉, 모든 요청이 무조건 코어 시스템을 거쳐 각 플러그인  
  서비스로 흘러가는 구조이다.

- 이처럼 플러그인 컴포넌트를 개별 서비스로 구현해서 원격 접근하는 방법은 전체 컴포넌트의 커플링이 낮아져 확장성과 처리량이 개선되고,  
  OSGi 등 특수한 프레임워크 없이도 런타임 변경이 가능하다는 장점이 있다. 또한 플러그인과 비동기 통신도 가능한데, 경우에 따라 이 덕에  
  유저 반응성을 엄청나게 끌어올릴 수 있다.

- 하지만 장점이 있으면 단점도 따르는 법인데, 원격 플러그인에 접속하려면 마이크로커널 아키텍쳐를 모놀리식이 아닌 분산 아키텍쳐로  
  바꿔야한다. 하지만 대부분의 3rd party 온프렘 제품은 그렇게 구현하거나 배포하기가 쉽지 않고, 전반적으로 복잡도와 비용이 높아져  
  전체 배포 topology가 상당히 난해해진다. 특히 REST로 소통할 때 플러그인이 무응답이거나 작동되지 않는 경우 요청이 완료될 수 없는데,  
  모놀리식으로 배포했다면 이런일은 없을 것이다. 플러그인 컴포넌트와 코어 시스템이 점대적으로 통신할지, 원격 액세스를 할지는 주어진  
  요구사항에 따라 선택해야할 문제이므로 장단점을 분석해 신중히 결정해야 한다.

- 플러그인 컴포넌트는 중앙 공유 DB에 직접 접근할 일이 거의 없다. 오히려 코어 시스템이 그 역할을 담당하며 필요한 데이터를 모두 가져와  
  각 플러그인에 전달한다. 이렇게 하는 가장 큰 이유는 디커플링이다. DB를 변경하는 행위는 코어 시스템에만 영향을 미치고, 플러그인  
  컴포넌트에는 아무런 영향을 끼치지 않으므로 플러그인은 자신만 액세스 가능한 DB를 가질 수 있다. 이러한 플러그인의 DB는  
  외부화하거나, in-memory 혹은 embedded DB와 같이 플러그인 컴포넌트 또는 모놀리식 배포의 일부로 내장할 수 있다.

---

## 12.2 레지스트리(Registry)

- 코어 시스템은 어떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야하는지 알고 있어야 한다.  
  이를 구현하는 가장 일반적인 방법은 플러그인 레지스트리를 경유하도록 하는 것이다.  
  이 레지스트리에는 플러그인의 명칭, 데이터 계약, 세부 원격 액세스 프로토콜 등 각 플러그인 모듈에 대한 정보가 들어있다.

- 레지스트리는 코어 시스템이 소유한 내부 map 구조처럼 단순할 수도 있고, 레지스트리 및 디스커버리를 위한 도구가 Apache Zookeeper,  
  Consul 처럼 코어 시스템이나 외부 배포된 시스템에 내장된 복잡한 형태일 수 있다.

- 아래 코드는 전자제품 재활용 애플리케이션의 단순한 레지스트리를 코어 시스템 내부에 Java로 구현한 예제이다.

```java
Map<String, String> registry = new HashMap<>();
static {
	// 점대점 액세스 예제
	registry.put("iphone15s", "Iphone15sPlugin");

	// messaging 액세스 예제
	registry.put("iphone15s", "iphone15s.queue");

	// REST 액세스 예제
	registry.put("iphone15s", "http://localhost:8080/assess/iphone15s");
}
```

---

## 12.3 계약

- 플러그인 컴포넌와 코어 시스템 간의 계약은 보통 플러그인 컴포넌트의 도메인 단위로 표준화되어 있고, 플러그인 컴포넌트가 수행하는 기능 및  
  입출력 데이터는 계약에 명시되어 있다. 3rd party 회사가 개발한 플러그인 컴포넌트의 계약을 마음대로 바꿀 수 없을 때는 보통 커스텀 계약을  
  사용하며, 일반적으로 코어 시스템이 각 플러그인별 코드를 필요로 하지 않도록 하기 위해 플러그인 계약과 직접 정한 표준 계약 간의 어댑터를 만들게 된다.

- 플러그인 계약은 플러그인과 코어 시스템이 서로 주고받는 XML, JSON, 또는 객체로 구현한다.

```java
public interface AssessmentPlugin {
	public AssessmentOutput assess();
	public String register();
	public String deregister();
}

public class AssessmentOutput {
	public String assessmentReport;
	public Boolean resell;
	public Double value;
	public Double resellPrice;
}
```

- 코어 시스템과 플러그인 컴포넌트 간의 역할 및 책임 모델이 어떻게 정립되었는지 보자.  
  특히 assessmentReport 필드를 보면, 코어 시스템은 단지 감정 리포트를 출력하거나 유저에게 보여주는 일만 할 뿐,  
  감정 리포트의 세부 내용을 포매팅하고 이해하는 것은 코어 시스템의 책임이 아니다.

---

## 12.4 실제 용례

- Eclipse IDE, Jira, Jenkins 등 많은 소프트웨어 개발, 릴리즈 도구가 마이크로커널 아키텍쳐를 사용해 개발되었다.  
  Chrome, Firefox 같은 웹브라우저도 마이크로커널 아키텍쳐를 응용한 제품으로, 각종 viewer와 플러그인을 장착하면 코어 시스템에  
  해당하는 기본 브라우저에 없는 부가 기능을 덧붙일 수 있다. 제품 기반의 소프트웨어 역시 용례는 무궁무진하지만, 마이크로커널 아키텍쳐는  
  대규모 비즈니스 애플리케이션에도 적합할 수 있다. 예를 들어, 보험금 청구건을 처리하는 보험 회사 시스템이 있다 해보자.

- 보험금 청구 프로세스는 관할 구역마다 청구 시 허용 및 금지된 규칙과 규정이 제각각이기에 아주 복잡하다.  
  표준 청구 프로세스의 가능한 경우의 수는 거의 무한에 가까울 정도다.

- 보험금 청구 처리 애플리케이션은 대부분 아주 크고 복잡한 규칙 엔진을 이용해 복잡한 로직을 처리하지만, 자칫 잘못해 이 규칙 엔진이  
  진흙잡탕이 되어 규칙 하나를 변경하면 다른 규칙들이 연쇄적으로 영향을 받거나, 단순한 규칙 하나를 바꾸려 하면 여러 분석가, 개발자,  
  테스터가 한데 모여 문제 여부를 검증해야하는 과정을 거치게 될 수도 있다. 이런 경우에 마이크로커널 아키텍쳐 패턴을 활용하면 좋다.

- 관할 구역별 보험금 청구 규칙을 별도의 standalone 플러그인 컴포넌트에 보관하도록 하면, 다른 시스템 파트에 영향을 주지 않고  
  특정 관할 구역의 규칙을 추가, 삭제, 변경할 수 있다. 그리고 관할 구역을 새롭게 추가하거나 기존 관할 구역을 삭제해도 다른 부분에는  
  영향이 없다. 코어 시스템은 바뀔 일이 거의 없는, 청구건을 접수받아 처리하는 표준 프로세스가 될 것이다.

---

## 12.5 아키텍쳐 특성 등급

- 아래 표에서 숫자가 1인 특성은 이 아키텍쳐에서 별로 잘 지원되지 않고, 5인 특성은 이 아키텍쳐의 강점 중 하나라는 뜻이다.

| 아키텍쳐 특성 | 별점           |
| ------------- | -------------- |
| 분할 유형     | 도메인 및 기술 |
| 퀀텀 수       | 1              |
| 배포성        | 3              |
| 탄력성        | 1              |
| 진화성        | 3              |
| 내고장성      | 1              |
| 모듈성        | 3              |
| 전체 비용     | 5              |
| 성능          | 3              |
| 신뢰성        | 3              |
| 확장성        | 1              |
| 단순성        | 4              |
| 시험성        | 3              |

- 마이크로커널 아키텍쳐도 layered 아키텍쳐처럼 단순성과 전체 비용이 주요 강점이다.  
  반면 고질적인 모놀리식 배포 탓에 탄력성, 내고장성, 확장성이 문제될 때가 많다.

- 모든 요청은 코어 시스템을 통해 유입되어 독립적인 플러그인 컴포넌트로 흘러가므로, 퀀텀은 언제나 1이다.

- 마이크로커널 아키텍쳐는 도메인 분할, 기술 분할이 모두 가능한 유일한 아키텍쳐 스타일이다.  
  대부분의 경우 기술 분할되지만, 도메인 분할 역시 가능하다.

- 기능을 독립적인 플러그인 컴포넌트로 분리할 수 있으므로 시험성, 배포성, 신뢰성은 3이다.  
  잘 분할하기만 한다면 (특히 플러그인 컴포넌트를 런타임에 배포하는 경우) 변경분에 대한 전체 테스트 범위와 배포 리스크가 줄어들 것이다.
