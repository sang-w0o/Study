# 10. Layered 아키텍쳐 스타일

- Layered 아키텍쳐(n-tiered architecture)는 가장 흔한 아키텍쳐 스타일 중 하나로, 단순하고 대중적이면서 비용도 적게 들어  
  모든 애플리케이션의 사실상 표준 아키텍쳐이다. 시스템을 설계하는 조직은 그 조직의 소통 구조를 그대로 복제한 듯 설계할 수 밖에  
  없다는 콘웨이의 법칙을 떠올려보면, 이 아키텍쳐는 아주 자연스러운 방법이다.

- 하지만 이 아키텍쳐 스타일은 묵시적 아키텍쳐 안티패턴(architecture by implication), 우발적 아키텍쳐 안티패턴(acciedental  
  architecture) 등의 몇몇 아키텍쳐 안티패턴의 범주에 속한다.

- 만약 개발자, 아키텍트가 어떤 아키텍쳐 스타일을 사용하는게 좋을지 확신이 없거나 애자일 개발팀이 '일단 코딩을 시작'하기로 한다면  
  layered 아키텍쳐는 좋은 선택지가 될 가능성이 높다.

---

## 10.1 Topology

- Layered 아키텍쳐에서 내부 컴포넌트는 논리적으로 수평한 layer들로 구성되며, 각 layer는 애플리케이션에서 presentation 로직,  
  비즈니스 로직 등 주어진 역할을 수행한다. Layer의 개수와 유형은 특별한 제약이 없지만, 일반적으로 presentation, business,  
  persistence, database의 4개 표준 layer로 구성된다. SQL과 같은 persistence 로직이 business layer의 컴포넌트에  
  내장된 경우에는 persistence layer를 business layer에 병합시킨다. 따라서 보통 규모가 작은 애플리케이션은 3개, 덩치가 크고  
  복잡한 애플리케이션은 5개 혹은 그 이상의 layer로 구성된다.

- 물리적 계층화(layering) 배포 관점에서의 다양한 토폴로지 변형을 보자.  
  Presentation, business, persistence layer를 단일 배포 단위로 합치고, database layer만 외부에 별도로 분리해  
  물리적인 데이터베이스로 가져갈 수 있다. 또한 presentation layer를 자체 배포 단위로 떼어내고, business layer와  
  persistence layer를 합쳐갈 수 있다. 이 구조에서도 database layer는 외부 database나 파일 시스템으로 분리된다.  
  마지막으로 database layer를 포함한 4개 표준 layer를 모두 함께 단일 배포 단위로 가져갈 수 있다. 이 구성은 애플리케이션에  
  database layer가 내장되어 있거나 in-memory database를 사용하는 소규모 애플리케이션에 적합한 구성이다.

- Layered 아키텍쳐 스타일에서 각 layer는 아키텍쳐 내부에서 특정한 역할과 임무를 수행한다.  
  Presentation layersms user interface와 브라우저 통신 로직을, business layer는 요청을 받아 알맞은 비즈니스 규칙을  
  실행하는 일을 한다. 각 layer는 주어진 비즈니스 요건을 충족하는 데 필요한 업무 위주로 추상화되어 있다.  
  예를 들어, presentation layer는 고객 데이터를 조회하는 방법을 알 필요가 없고, 그럴 이유도 없다. 그저 자신이 받아온 데이터를  
  화면에 보기 좋게 보여주면 그만이다. 마찬가지로 business layer는 고객 데이터를 어디서 가져올지, 화면에는 어떻게 보여줄지  
  전혀 관여하지 않는다. Persistence layer에서 데이터를 가져와 비즈니스 로직을 수행한 결과 데이터를 presentation layer에  
  전달하기만 하면 된다.

- 이러한 관심사의 분리(separation of concerns) 개념 덕에 layered 아키텍쳐 스타일은 아키텍쳐 내부의 역할 및 책임 모델을  
  효과적으로 구성할 수 있다. 특정 layer에 소속된 컴포넌트는 역할 범위가 한정되며, 그 layer에 알맞은 로직만을 처리한다.  
  따라서 개발자 본인의 기술 역량을 도메인의 기술적인 부분에 집중시킬 수 있지만, 이런 장점을 대가로 전체적인 민첩성(변화에 신속히  
  대응하는 능력)이 떨어지는 tradeoff가 있다.

- Layered 아키텍쳐는 도메인 분할 아키텍쳐의 반대인 기술 분하된 아키텍쳐이다. 즉, 컴포넌트를 도메인 단위로 묶는게 아니라  
  아키텍쳐의 기술 역할에 따라 묶기에 비즈니스 도메인이 각각 모든 아키텍쳐 layer에 분산된다. 예를 들어, '고객' 도메인은  
  presentation, business, persistence, database 등 모든 layer에 다 포함되므로 이 도메인에 어떠한 변경을  
  가하는 일이 쉽지 않다. 이런 이유로 이 아키텍쳐 스타일은 DDD와는 잘 안 맞다.

---

## 10.2 Layer 격리

- Layered 아키텍쳐의 각 layer는 폐쇄(closed) 또는 개방(open) 상태이다.  
  폐쇄 layer란, 요청이 상위 layer에서 하위 layer로 이동하므로 중간의 어떤 layer도 건너뛸 수 없고, 현재 layer를 거쳐야 바로 그  
  다음 layer로 나아갈 수 있다는 뜻이다. 예를 들어, presentation layer에서 시작된 요청은 일단 business layer로 들어간 후,  
  persistence layer를 거쳐 제일 마지막 database layer에 도달한다.

```
presentation layer
  |
  v
business layer
  |
  v
persistence layer
  |
  v
database layer
```

- 하지만 단순 조회 요청이라면 불필요한 layer를 건너뛰고 presentation에서 곧바로 database layer에 접근하는 것이 더 빠르고 간편할  
  것이다. 이렇게 요청이 다른 layer를 건너뛸 수 있으려면 business, persistence layer는 개방이 되어 있어야 한다.  
  폐쇄 layer와 개방 layer 중 어느 것이 나을까? 이 질문에 답하려면 layer 격리(layers of isolation) 개념을 이해해야 한다.

- Layer 격리는 어느 아키텍쳐 layer에서 변경이 일어나도, 다른 layer에 있는 컴포넌트에 아무런 영향을 끼치지 않기에 layer 간의 계약은  
  불변임을 의미한다. 각 layer는 서로 독립적으로 작동되므로 다른 layer의 내부 작동 로직은 거의/전혀 알지 못한다.  
  Layer 격리를 지원하려면 요청의 메인 흐름에 대한 layer가 반드시 폐쇄되어 있어야 한다. Presentation layer가 persistence  
  layer에 직접 접근할 수 있으면 persistence layer에 변경이 발생할 경우 business, presentation layer 둘 다 영향을  
  받게 되고, 결국 컴포넌트 간의 layer 상호 의존도가 높아져 단단히 커플링된 애플리케이션이 될 것이다.  
  이런 아키텍쳐는 매우 취약하고, 변경하기 힘들고, 비용도 많이 든다.

- 또 layer를 격리하면 아키텍쳐의 모든 layer를 다른 layer에 영향을 주지 않고 교체할 수 있다.  
  가령, 오래된 JSF(JavaServer Faces) presentation layer를 React.JS로 교체할 때 layer 격리 개념을 적용하면  
  다른 layer에 아무런 영향을 미치지 않고서도 작업이 가능하다.

---

## 10.3 Layer 추가

- 아키텍쳐 내부적으로 폐쇄 layer를 이용해 변경을 격리할 수 있지만, 어떤 layer는 개방하는게 더 합리적인 경우도 있다.  
  예를 들어 날짜, 문자열 utility class, 로깅 등 공통 비즈니스 기능이 구현된 객체를 구현해 공유하고, presentation layer는  
  이 공유 객체를 직접 사용할 수 없도록 아키텍쳐 결정을 했다고 해보자.

- 이런 제약 조건을 아키텍쳐적으로 강제하려면 공유 비즈니스 객체가 모두 포함된 새로운 service layer를 presentation layer와  
  business layer 사이에 추가하면 된다. 이렇게 하면 business layer는 폐쇄되어 있으니 아키텍쳐 구조상 presentation layer가  
  공유 비즈니스 객체에 직접 접근할 수 없다. 그러나 새로 추가한 service layer는 개방 layer로 설계해야 business layer가  
  persistence layer에 접근할 때 service layer를 뚫고 갈 수 있을 것이다. Service layer를 개방 layer로 만들어 추가하면,  
  business layer는 이 layer에 접근하거나 이 layer를 지나쳐 다음 layer로 향할 수 있다.

- 개방/폐쇄 layer 개념을 잘 활용하면 아키텍쳐 layer 간 관계와 요청 흐름을 정의할 때 유용하다.  
  아키텍쳐의 어떤 layer가 개방/폐쇄되어 있는지 정확히 문서화해 소통하지 않으면 테스트, 유지보수, 배포 작업이 아주 힘든, 단단히  
  커플링되어 금방이라도 깨질 듯한 아키텍쳐가 되어버릴 것이다.

---

## 10.4 기타 고려 사항

- Layered 아키텍쳐에서는 아키텍쳐 싱크홀(architecture sinkhole) 안티패턴을 조심해야 한다.  
  요청이 한 layer에서 다른 layer로 이동할 때, 각 layer가 아무런 비즈니스 로직도 처리하지 않고 그냥 통과시키는 안티패턴을 말한다.  
  예를 들어, 유저가 기본 고객 데이터를 조회하는 단순 요청을 하면 presentation layer가 응답하는 아키텍쳐가 있다고 해보자.  
  Presentation layer는 business에, business는 아무 일도 하지 않은 채 persistence layer에 요청을 전달하고,  
  persistence layer가 database layer에 단순 조회 SQL을 실행해 고객 데이터를 가져오면, 취합, 계산, 규칙 적용 등  
  일체의 로직 없이 다시 왔던 과정을 거꾸로 돌아간다. 이런 흐름은 불필요한 객체 초기화 및 처리를 빈번하게 유발하고, 쓸데없이  
  메모리를 소모하며 성능에도 부정적인 영향을 끼친다.

- 아키텍쳐 시크홀 안티패턴에 해당하는 시나리오가 전무한 layered 아키텍쳐는 아마 하나도 없을 것이다.  
  그러므로 이 안티패턴으로 처리 중인 요청의 전체 비율을 따져보는 것이 중요하다. 80:20 법칙을 적용해 전체 요청의 20%가  
  싱크홀인 정도이면 그런대로 괜찮은 수준이다. 그러나 분석 결과 80%가 싱크홀이라면, 해당 문제 도메인에 layered 아키텍쳐가  
  적합한 아키텍쳐 스타일이 아니라는 증거이다. 아키텍쳐 싱크홀 안티패턴을 해결하는 또다른 방법은 아키텍쳐의 모든 layer를  
  개방하는 것이다. 그러나 이는 아키텍쳐상 변경 관리의 어려움이 가증되는 tradeoff가 있음을 분명히 인식해야 한다.

---

## 10.5 왜 이 아키텍쳐 스타일을 사용하는가

- Layered 아키텍쳐는 작고 단순한 애플리케이션이나 웹사이트에 알맞은 아키텍쳐 스타일이다.  
  특히 처음 구축을 시작할 때 예산과 일정이 빠듯할 경우 출발점으로 괜찮은 아키텍쳐 선택이다.  
  개발자, 아키텍트 모두 익숙하고 그리 복잡하지 않으며, 어쩌면 비용도 가장 저렴한 아키텍쳐 스타일이므로 소규모 애플리케이션을  
  간편하게 개발할 수 있다.

- Layered 아키텍쳐 기반의 애플리케이션은 규모가 커질수록 유지 보수성, 민첩성, 시험성, 배포성 같은 아키텍쳐 특성이  
  점점 나빠진다. 따라서 layered 아키텍쳐를 사용한 대규모 애플리케이션이나 시스템은 다른 더 모듈러한 아키텍쳐 스타일이 더 잘 맞다.

---

## 10.6 아키텍쳐 특성 등급

- 아래 표에서 숫자가 1인 특성은 이 아키텍쳐에서 별로 잘 지원되지 않고, 5인 특성은 이 아키텍쳐의 강점 중 하나라는 뜻이다.

| 아키텍쳐 특성 | 별점 |
| ------------- | ---- |
| 분할 유형     | 기술 |
| 퀀텀 수       | 1    |
| 배포성        | 1    |
| 탄력성        | 1    |
| 진화성        | 1    |
| 내고장성      | 1    |
| 모듈성        | 1    |
| 전체 비용     | 5    |
| 성능          | 2    |
| 신뢰성        | 3    |
| 확장성        | 1    |
| 단순성        | 5    |
| 시험성        | 2    |

- 전체 비용과 단순성이 주요 강점이다. 이 아키텍쳐는 원래 모롤리식에 가깝기에 분산 아키텍쳐 스타일에 따른 복잡도가 낮고,  
  구조가 단순해서 알기 쉬운데다 구축 및 유지보수 비용도 비교적 적게 든다. 그러나 모놀리식 layered 아키텍쳐가 점점 커지고  
  결과적으로 더 복잡해지면 이런 장점들도 사라진다는 사실에 유의해야 한다.

- Layered 아키텍쳐 스타일은 배포성과 시험성 별점이 매우 낮다. 배포를 하려면 절차가 까다롭고 리스크가 높으며, 자주 배포할 수 없기에  
  배포성은 떨어진다. 클래스 파일 3줄 정도의 작은 변경을 해도 전체적으로 다시 배포해야 하고, 데이터베이스 변경, 구성 변경도 수반될 수  
  있으며, 다른 코드도 함께 고쳐야 할 수 있다. 같은 이유로 시험성도 낮은데, 코드 3줄만 고치면 되는데 전체 회귀 테스트 케이스를  
  작성해 실행하지 않거나, 수십가지 다른 변경을 동시 반영할 경우 문제가 커질 수 있다. 그래도 시험성이 1이 아닌 2인 이유는  
  컴포넌트 전체를 mocking, stubbing할 수 있어 전체 테스트 공수가 덜 들기 때문이다.

- 분산 아키텍쳐와 비교했을 때 일반적인 네트워크 트래픽, 대역폭, latency 문제는 덜 하므로 신뢰성은 3이지만, 모놀리식 배포 속성상  
  배포 리스크 측면에서 점수는 낮을 수 밖에 없다.

- 이 아키텍쳐는 모놀리식 배포와 아키텍쳐 측면에서 모듈성이 부족해 탄력성과 확장성은 1이다. 모놀리식 내부 기능 중에는 상대적으로  
  확장이 가능한 것들도 더러 있지만, 그렇게 하려면 대부분 멀티스레딩, 내부 메시징을 비롯해 이 아키텍쳐와는 어울리지 않는 갖가지  
  병렬 처리 기법이 동원된다. 그러나 layered 아키텍쳐는 UI, 백엔드 처리, 데이터베이스 구조가 모놀리식이고 언제나 단일 시스템  
  퀀텀이므로 애플리케이션은 단일 퀀텀을 기반으로 특정 지점까지만 확장이 가능하다.

- 성능은 애매하지만 2를 선택했다. 이 아키텍쳐 스타일은 병렬 처리가 거의 안되고, 폐쇄적인 layer 구조와 싱크홀 아키텍쳐 안티패턴  
  때문에 고성능 시스템에 어울리지 않기 때문이다.

- Layered 아키텍쳐는 모놀리식 배포 때문에, 또 부족한 아키텍쳐 모듈성 때문에 내고장성도 별로다.  
  어느 한 작은 부분에 OOM이 발생하면 애플리케이션이 전체적으로 영향을 받고 충돌이 발생한다.  
  그리고 대부분의 모놀리식 애플리케이션이 겪는 MTTR(Mean-Time-To-Recovery) 때문에 소규모 애플리케이션은 2분,  
  대규모 애플리케이션은 대부분 15분 이상의 시동 시간이 소요되며, 그만큼 전체 가용성도 영향을 받는다.

---
