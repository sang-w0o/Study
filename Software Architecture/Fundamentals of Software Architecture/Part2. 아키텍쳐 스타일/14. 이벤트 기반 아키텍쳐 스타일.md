# 14. 이벤트 기반 아키텍쳐 스타일

- 이벤트 기반 아키텍쳐(Event Driven Architecture)는 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 사용되는  
  비동기 분산 아키텍쳐 스타일이다. 적응성이 뛰어나 소규모 애플리케이션부터 크고 복잡한 애플리케이션까지 두루 사용 가능하다.  
  이벤트 기반 아키텍쳐는 이벤트를 비동기 수신/처리하는 별도의 이벤트 처리 컴포넌트들로 구성되며, standalone 아키텍쳐 스타일로  
  사용하거나, 다른 아키텍쳐 스타일(ex. 이벤트 기반 MSA)에 내장할 수도 있다.

- 애플리케이션은 대부분 요청 기반 모델(request-based model)을 따른다. 이 모델에서는 어떤 액션을 수행하도록 시스템에 요청하면  
  요청 orchestrator가 접수한다. 요청 orchestrator는 보통 UI이지만, API layer나 엔터프라이즈 서비스로도 구현할 수 있다.  
  이 컴포넌트의 업무는 다양한 요청 프로세서(request processor)에 확정적으로(deterministically), 동기적으로 요청을  
  전달하는 일이다. 요청 프로세서는 요청을 받아 데이터베이스에서 정보를 조회/수정하는 등의 작업을 수행하는 식으로 요청을 처리한다.

- 예를 들어 어떤 시스템에서 유저의 주문 이력을 검색한다고 해보자. `주문 이력 조회`는 특정한 context에서 시스템에 데이터를 달라고  
  전달된, 데이터 기반의 확정적인 요청이지, 시스템이 반응해야 할 이벤트가 발생한 것은 아니다.

- 반면, 이벤트 기반 모델은 특정한 상황에 대응해 그 이벤트에 맞게 액션을 취한다.  
  예를 들어, 온라인 경매 사이트에서 어떤 품목에 대한 입찰을 한다고 해보자. 입찰을 하는 행위는 시스템에 뭔가를 요청하는 것으로  
  볼 수도 있지만, 현재 가격이 발표된 직후에 발생하는 이벤트에 더 가깝다. 시스템은 이 이벤트에 반응함으로써 동시 발생한 다른  
  입찰가와 비교 후 최고 입찰가를 갱신한다.

---

## 14.1 Topology

- 이벤트 기반 아키텍쳐의 주요 topology는 중재자(mediator) topology와 broker topology이다.  
  주로 중재자 topology는 이벤트 처리 workflow를 제어해야 할 경우에, broker topology는 신속한 이벤트와 동적인 이벤트  
  처리 제어가 필요할 때 각각 사용된다.

- 이 두 topology의 아키텍쳐 특성과 구현 전략은 서로 다르기에 주어진 상황에 가장 알맞은 것을 선택하려면 각 특징을 정확히 이해해야 한다.

---

## 14.2 Broker Topology

- Broker topology는 중앙에 이벤트 중재자가 없다는 점에서 중재자 topology와 다르다.  
  메시지는 RabbitMQ, ActiveMQ 등의 경량 message broker를 통해 broadcasting 되는 식으로 이벤트 프로세서 컴포넌트에  
  분산되어 흘러간다. 이 topology는 비교적 이벤트 처리 흐름이 단순하고, 굳이 중앙에서 이벤트를 조정할 필요가 없을 때 사용한다.

- Broker topology는 네 가지 기본 아키텍쳐 컴포넌트로 구성된다.

  - 시작 이벤트(initiating event): 단순한 이벤트든 복잡한 이벤트든, 전체 이벤트 흐름을 개시하는 이벤트를 말한다.  
    시작 이벤트는 이벤트 broker의 이벤트 채널로 전송되어 처리된다. 이벤트를 관리, 제어하는 중재자가 broker topology에  
    없으므로 단일 이벤트 프로세서는 이벤트 broker에서 시작 이벤트를 받자마자 관련된 작업을 마친 뒤, 처리 이벤트(processing event)를  
    생성하고, 시스템의 나머지 부분에 자신이 한 일을 비동기로 알린다. 이 처리 이벤트는 필요시 부가적인 처리를 위해 이벤트 broker에  
    비동기 전송된다. 다른 이벤트 프로세서는 처리 이벤트를 리스닝하고 있다가, 이벤트가 들어오면 그에 맞는 작업을 수행한 뒤, 다시 새로운  
    처리 이벤트를 발행함으로써 자신이 한 일을 모두에게 알린다. 이 과정은 최종 이벤트 프로세서가 한 일에 아무도 관심이 없을 때까지 되풀이된다.

  - 이벤트 broker 컴포넌트는 통 연합체(도메인 기반으로 clustering된 다수의 인스턴스)로 구성되며, 연합된 각 브로커에는  
    주어진 도메인의 이벤트 흐름에서 사용되는 모든 이벤트 채널이 들어있다. Broker topology는 속성 상 fire-and-forget 방식으로  
    비동기 broadcasting 하므로 topic은 일반적으로 발행-구독 메시징 모델을 사용하는 broker topology에서 사용된다.

- Broker topology에서는 다른 이벤트 프로세서의 관심 여부와 무관하게, 각 이벤트 프로세서가 자신이 한 일을 모두에게 알리는게 항상  
  바람직하다. 그래야 나중에 이벤트를 처리하는 과정에서 기능 추가가 필요하게 되더라도, 아키텍쳐를 쉽게 확장할 수 있다.  
  어짜피 버려지거나 무시될 메시지를 보내는 것이 리소스 낭비라고 생각할 수도 있지만, 실은 그렇지 않다.  
  이후에 최소한의 작업으로 새로운 요구사항을 받아들일 수 있기 때문이다.

- Broker topology에서는 모든 이벤트 프로세서가 고도로 분리되어 있고, 서로 독립적으로 움직인다.  
  마치 릴레이 경주처럼, 이벤트 프로세서는 이벤트를 전달한 후 더 이상 그 이벤트에는 관여하지 않고, 다른 시작 이벤트 또는 처리 이벤트에  
  반응할 준비를 한다. 또한 각 이벤트 프로세서는 이벤트 처리 도중 가변적인 부하나 백업 조건을 처리하기 위해 서로 독립적으로  
  확장할 수도 있다. 만약 어떤 환경 문제로 인해 이벤트 프로세서가 느려지거나 실패하면, 해당 프로세서가 구독하는 topic이  
  배압(backpressure) 지점이 된다.

- Broker topology는 성능, 응답성, 확장성 측면에서 장점이 많지만 그만큼 단점도 많다.  
  무엇보다 시작 이벤트와 연관된 전체 workflow를 제어할 수가 없다. 따라서 다양한 조건에 따라 상황이 매우 유동적이고 어느 시스템 파트도  
  실제로 workflow가 언제 끝났는지 모른다. 에러 처리 역시 어려운데, 비즈니스 트랜잭션을 관리, 통제하는 중재자가 없으므로 처리가 실패하더라도  
  다른 파트는 그 사실을 모른다. 결국 비즈니스 프로세스는 교착 상태에 빠지고 자동이든 수동이든 뭔가 다른 조치를 해주지 않으면 프로세스는 정체된다.

- 비즈니스 트랜잭션을 재시작하는 기능(복구성)도 broker topology에서는 지원되지 않는다.  
  처음 시작 이벤트를 처리할 때부터 이미 다른 작업이 비동기로 수행되었기에 시작 이벤트를 다시 넣는 것은 불가능하다.  
  Broker topology에 있는 어느 컴포넌트도 상태를 모르고 원래 비즈니스 요청 상태를 갖고 있으므로, 어디서부터 비즈니스 트랜잭션을  
  다시 시작해야 할지 알 수 없는 것이 당연하다.

| 장점                         | 단점            |
| ---------------------------- | --------------- |
| 이벤트 프로세서의 decoupling | workflow 제어   |
| 확장성                       | 에러 처리       |
| 응답성                       | 복구성          |
| 성능                         | 재시작 능력     |
| 내고장성                     | 데이터 비일관성 |

---

## 14.3 중재자 Topology

- 중재자 topology는 broker topology의 단점들을 일부 보완한다.  
  여러 이벤트 프로세서 간의 조정이 필요한 시작 이벤트에 대해 workflow를 관리, 제어하는 이벤트 중재자(event mediator)가 핵심이다.  
  중재자 topology는 시작 이벤트, 이벤트 queue, 이벤트 중재자, 이벤트 채널, 이벤트 프로세서의 5가지 아키텍쳐 컴포넌트로 구성된다.

- 시작 이벤트가 전체 이벤트 프로세스를 개시하는 이벤트인 점은 broker topology와 동일하지만, 중재자 topology에서는 시작 이벤트를  
  queue를 거쳐 이벤트 중재자로 전달한다는 차이점이 있다. 이벤트 중재자는 이벤트 처리에 대한 단계별 정보를 갖고 있으므로, point-to-point  
  messaging으로 각각의 이벤트 채널(대부분 queue)로 전달되는 처리 이벤트를 생성한다. 그러면 각 이벤트 프로세서는 자신의 이벤트 채널에서  
  이벤트를 받아 처리한 다음, 중재자에게 작업을 완료했다고 응답한다. 이벤트 프로세서가 다른 프로세서에게 자신이 한 일을 알리지 않았다는  
  점도 broker topology와 다른 점이다.

- 중재자 topology의 구현체에는 대부분 특정 도메인이나 이벤트 그룸과 연관된 중재자가 여럿 존재하므로 SPoF를 줄이고, 전체 처리량과 성능을 높일 수 있다.

- 이벤트 중재자는 처리하는 이벤트의 특성과 복잡도에 따라 다양한 방법으로 구현할 수 있다.  
  간단한 에러 처리와 orchestration이 필요한 이벤트는 단순한 프레임워크로도 구현이 가능하다. 보통 이런 중재자는 이벤트 workflow를 코드로 제어한다.

- 이벤트 workflow에 조건부 처리가 많고 동적 경로가 많아 에러 처리가 복잡하다면, 조금 더 복잡한 구성을 지원하는 프레임워크로 구현할 수 있다.

- 이벤트의 복잡도를 한 가지 기준으로 평가하는 경우는 거의 없으므로 알기 쉽게 단순함, 어려움, 복잡함 정도로 구분한 뒤, 모든 이벤트가 항상 단순한  
  중재자를 먼저 거치도록 하는 것이 좋다. 이 단순한 중재자는 이벤트 등급에 따라 이벤트를 직접 처리하거나, 더 복잡한 다른 이벤트 중재자에게 위임한다.  
  이런 식으로 모든 종류의 이벤트를 그에 맞는 중재자가 효과적으로 처리할 수 있도록 구성한다.

- 중재자 컴포넌트는 broker topology와는 달리, workflow에 대해 잘 알고 있고 통제가 가능하다.  
  중재자는 workflow를 제어하므로 이벤트 상태를 유지하면서 필요 시 에러 처리, 복구, 재시작을 할 수 있다.

- 두 topology는 처리 이벤트의 의미와 사용 방법이 완전히 다르다.  
  Broker topology에서는 시스템에서 발생한 이벤트로서 처리 이벤트가 발행되고, 이벤트 프로세서는 각자 맡은 일을 하면서  
  나머지 프로세서는 그 액션에 반응하는 식으로 동작한다. 하지만 중재자 topology에서의 처리 이벤트는 사건(incident)이 아니라,  
  명령(command, 일어나야할 일)이다. 따라서 중재자 topology에서는 처리 이벤트가 처리되어야할 이벤트인 반면, broker topology에서는  
  그냥 무시해도 되는 것이다.

- 이처럼 중재자 topology는 broker topology의 단점을 보완하지만, 그만큼 부정적인 요소들도 있다.  
  먼저 복잡한 이벤트 흐름 내에서 밝생하는 동적인 처리를 선언적으로 모델링하기가 매우 어렵다. 그래서 보통은 중재자의 내부 workflow는  
  일반적인 처리만 하고, 복잡한 이벤트 처리의 변화무쌍한 부분은 중재자+broker 형태의 하이브리드 형태로 처리한다.  
  다음으로, 이벤트 프로세서는 broker topology에서처럼 쉽게 확장할 수 있지만, 그러려면 중재자도 함께 확장해야하므로 전체 이벤트 처리  
  흐름에 병목 지점이 생기기 쉽다. 마지막으로 중재자 topology는 이벤트 처리를 중재자가 제어하므로 이벤트 프로세서가 상대적으로 더 많이  
  coupling되어 성능은 broker topology보다 좋지 못하다.

| 장점          | 단점                       |
| ------------- | -------------------------- |
| workflow 제어 | 이벤트 프로세서의 coupling |
| 에러 처리     | 확장성                     |
| 복구성        | 성능                       |
| 재시작 능력   | 내고장성                   |
| 데이터 일관성 | 데이터 비일관성            |

- Broker topology, 중재자 topology 중 선택은 결국 workflow의 제어와 에러 처리 기능이 우선인지, 아니면 고성능과 확장성이 더  
  중요한가의 tradeoff를 잘 따져 선택할 수 밖에 없다. 중재자 topology의 성능과 확장성도 그리 나쁜 수준은 아니지만, broker topology  
  만큼은 못한 것이 사실이다.

---

## 14.4 비동기 통신

- 이벤트 기반 아키텍쳐 스타일은 consumer에게 응답을 받아야 하는 요청/응답 처리 뿐만 아니라, 응답이 필요 없는 fire-and-forget  
  처리 모두 비동기 통신만 사용한다는 점에서 다른 아키텍쳐 스타일과 다르다. 비동기 통신은 시스템의 응답성을 전반적으로 높이는 강력한  
  기법으로 활용할 수 있다.

- 비동기 통신에서는 에러 처리가 가장 큰 문제이다. 예를 들어, 주식을 배수하는 행위를 비동기 처리로 구현했는데, 만약 실제로는 구매에  
  실패했다면 어떻게 할 것인가?

---

## 14.5 에러 처리

- 비동기 workflow에서 에러 처리 문제를 해결하는 한 가지 방법으로 reactive 아키텍쳐의 workflow event 패턴을 꼽을 수 있다.  
  이는 탄력성과 응답성을 모두 겨냥한 reactive 아키텍쳐 패턴의 일종이다. 즉, 시스템을 응답성에 영향을 미치지 않고 탄력적으로 에러를  
  처리할 수 있게 만드는 패턴이다.

![picture 0](/images/FOSA_14_1.png)

- 위 그림에서 보다시피 workflow event 패턴은 workflow delegate(workflow 대리자)를 통해 위임(delegation),  
  봉쇄(containment), 수리(repair) 작업을 한다. 이벤트 producer는 메시지 채널을 통해 데이터를 이벤트 consumer에게  
  비동기 전송하고, consumer가 데이터를 처리하는 중 에러가 발생하면 즉시 해당 에러를 workflow processor에게 위임한 뒤,  
  이벤트 queue에 있는 다음 메시지로 넘어간다. 이렇게 에러가 발생해도 바로 다음 메시지를 처리하므로 전체 응답성은 영향을 받지 않는다.  
  만약 이벤트 consumer가 에러를 해결하느라 시간을 소비한다면, 그동안 queue에 있는 다음 메시지는 읽지 못하게 되기에  
  응답성에도 영향을 끼치게 될 것이다.

- 에러를 수신한 workflow processor는 메시지를 통해 무엇이 문제인지 확인하게 된다. 메시지를 확인해 (사람의 개입 없이)  
  원데이터를 변경해 긴급 조치한 후, 원래 queue로 다시 보내게 되고, 이를 소비하는 consumer는 이 메시지를 새로운 메시지처럼  
  처리하게 된다. 해결 불가능하거가 조치가 되어 있지 않은 오류를 만나게 되면, 위 그림에서는 dashboard라고 불리는 별도의  
  queue로 보내 담당자가 직접 확인하도록 한다.

- Workflow event 패턴에서 주의할 점은, 에러가 발생한 메시지를 workflow processor가 조치한 후 다시 producing하면,  
  처리 순서가 뒤로 밀릴 수 있다는 것이다. 모든 경우에 이에 대한 대비를 해야하는 것은 아니지만, 처리 순서가 중요한 이벤트라면  
  처리 순서를 보장하기 위한 별도 조치가 필요하다.

---

## 14.6 데이터 소실 방지

- 비동기 통신을 할 때 data loss는 언제나 중요한 관심사인데, 불행하게도 이벤트 기반 아키텍쳐는 데이터가 소실될만한 곳이 많다.  
  데이터 소실이란, 메시지가 도중에 삭제되거나 최종 목적지에 도달하지 못한 상태를 말한다.  
  비동기 메시징에서 데이터 소실을 방지하는 몇 가지 기본적인 기술을 살펴보자.

- 예시 상황으로 event processor A가 큐에 메시지를 비동기 전송하고, event processor B가 이 메시지를 받아 데이터베이스에  
  저장한다고 해보자. 이 시나리오에서 데이터 소실은 아래 경우에서 일어날 수 있다.

  - (1) A에서 메시지가 큐로 전달되지 않는 경우. 아니면 큐에는 도달했지만, B가 메시지를 읽기 전에 broker 전체가 장애가 난 경우.
  - (2) B가 큐에서 다음 메시지를 꺼내 이벤트를 처리하기 직전에 장애가 발생하는 경우
  - (3) 데이터 에러로 인해 B가 데이터베이스에 메시지를 저장할 수 없는 경우

- (1)번 이슈는 동기 전송(synchronous send)와 persistent message queue를 이용하면 쉽게 해결 가능하다.  
  Persistent message queue는 이른바 전달 보장(guaranteed delivery)도 지원한다.  
  즉, 메시지 브로커가 메시지를 수신하면 식속한 조회를 위해 메모리에 저장하는 동시에, 물리적 데이터 저장소인 file system 혹은  
  데이터베이스에도 메시지를 저장한다. 이렇게 하면, 메시지 브로커가 죽어도 메시지가 디스크에 물리적으로 저장되어 있기에, 브로커가  
  다시 살아날 때까지 메시지 처리를 계속할 수 있다. 그리고 동기 전송이라는 기법이 있는데, 이는 브로커가 메시지를 저장했다고 ACK를  
  줄 때까지 메시지 producer를 기다리게 하는 방식이다.

- (2)번 이슈 역시 client ACK mode를 이용하면 해결 가능하다. 기본적으로 메시지는 큐에서 빠져나가는 즉시 삭제되는데,  
  client ACK mode에서는 메시지를 큐에 보관한 채 다른 consumer가 읽어가지 못하게 clientID를 메시지에 부착한다.  
  따라서 B가 잘못되더라도 메시지는 큐에 계속 남아있으니 데이터 소실을 방지할 수 있다.

- (3)번 이슈는 데이터베이스가 제공하는 ACID transaction commit으로 해결 가능하다. 데이터베이스에 commit이 일어나면 데이터는  
  확실하게 저장된다. LPS(Last Participant Support)를 사용하면 메시지 처리가 끝나 데이터베이스에 저장되었음을 확인한 후  
  큐에서 메시지가 삭제된다.

---

## 14.7 Broadcasting

- 이벤트 기반 아키텍쳐에서는 메시지를 누가 받든, 그 메시지로 무엇을 하든 관계없이 이벤트를 broadcasting할 수 있다.

- Producer는 자신이 보낸 메시지를 누가 수신할지, 또 받아서 무슨 일을 할지 전혀 모른다.  
  따라서 어쩌면 broadcasting은 여러 이벤트 프로세서들을 가장 높은 수준으로 디커플링하는 수단이며 최종 일관성, 복잡한 이벤트 처리 등  
  다양한 쓰임새를 지닌 필수 기능이다.

---

## 14.8 요창-응답

- 때에 따라 서비스나 이벤트 프로세서 사이에 동기 통신이 필요한 경우가 있다.

- 이벤트 기반 아키텍쳐는 동기 통신을 요청-응답 메시징(request-response messaging) 방식으로 수행한다.  
  요청-응답 메시징 내부의 각 이벤트 채널은 요청 큐, 응답 큐로 구성된다. 처음 정보를 요청하면 요청 큐에 메시지가 비동기 전송된 후  
  메시지 producer에 제어권이 반환되며, producer는 응답 큐에 응답이 도착하길 기다리며 blocking wait 상태가 된다.  
  메시지 consumer가 메시지를 받아 처리한 후 응답 큐에 응답을 보내면, producer는 응답 데이터가 포함된 메시지를 수신하게 된다.

- 요청-응답 메시징을 구현하는 주요한 기술은 크게 두 가지가 있다.

  - (1) 메시지 헤더에 correlation ID를 사용하는 방식. Correlation ID는 응답 메시지의 필드로, 대부분 요청 메시지의 ID로 설정한다.
    ![picture 1](/images/FOSA_14_2.png)

  - (2) 응답 큐에 임시 큐를 두고 요청-응답 메시징을 구현한다. 임시 큐는 지정된 요청에만 사용되는데, 요청이 들어오면 생성되고, 요청이  
    종료되면 삭제된다. 이 임시 큐는 각 요청별로 producer만 알고 있는 전용 큐이므로 correlation ID는 필요하지 않다.  
    임시 큐의 작동 메커니즘은 아래와 같다.
    - (1) Producer가 임시 큐를 생성하고 `reply-to` header (혹은 사전 정의된 custom header)에 임시 큐의 이름을 설정해  
      요청 큐에 매시지를 보낸다.
    - (2) Producer는 임시 응답 큐를 blocking wait 하면서 응답이 도착하길 기다린다. 이 큐에 전달된 메시지는 원메시지를 보낸 producer만  
      확인할수 있으므로 별도의 correlation ID는 필요없다.
    - (3) Consumer는 메시지를 받아 처리한 후 `reply-to` header에 세팅된 값을 가진 응답 큐로 응답 메시지를 보낸다.
    - (4) Producer가 메시지를 수신한 후 임시 큐를 삭제한다.

- 이 두가지 방식을 비교했을 때, 기술적으로는 임시 큐가 훨씬 단순하지만, 브로커가 매번 요청을 할 때마다 임시 큐를 생성하고 폐기하는  
  일을 반복해야 하는 단점이 있다. 따라서 대용량 메시지 처리 시, 메시지 브로커의 속도가 크게 떨어지고, 이는 전체 성능과 응답성에도  
  영향을 끼칠 수 있다. 그래서 일반적으로는 correlation ID를 사용하는 방식을 선호한다.

---

## 14.9 요청 기반이냐, 이벤트 기반이냐

- 요청 기반 모델과 이벤트 기반 모델 모두 소프트웨어 시스템을 설계하는 유효한 접근 방식이다.  
  그러나 시스템이 전체적으로 성공하려면, 가장 알맞은 모델을 선택하는 것이 중요하다.  
  Workflow의 확정성과 제어가 중요하면 체계적인 데이터 기반의 요청에 특하된 요청 기반 모델을, 복잡하고 동적인 유저 처리 등 주로  
  고도의 응답성과 확장성을 요하는, 유연한 액션 단위의 이벤트를 처리한다면 이벤트 기반 모델이 좋은 선택지가 될 것이다.

- 아래 표는 요청 기반 모델과 비교한 이벤트 기반 모델의 장단점을 나타낸 것이다.
  | 요청 기반 모델보다 장점 | 요청 기반 모델보다 단점 |
  | ---------------------- | ---------------------- |
  | 동적인 컨텐츠의 응답성이 좋음 | 최종 일관성만 지원 |
  | 우수한 확장성, 탄력성 | 처리 흐름을 제어하기 어려움 |
  | 우수한 민첩성과 변화 관리 | 이벤트 흐름의 결과 예측의 어려움 |
  | 높은 응답성과 성능 | - |
  | 실시간 의사 결정 가능 | - |
  | 상황 인지에 따른 좋은 반응성 | - |

---

## 14.10 하이브리드 이벤트 기반 아키텍쳐

- 이벤트 기반 아키텍쳐와 다른 아키텍쳐 스타일을 함께 사용하는 하이브리드 아키텍쳐 기반의 애플리케이션도 있다.  
  이벤트 기반 아키텍쳐를 다른 아키텍쳐 스타일의 일부로 활용하는 아키텍쳐 스타일로는 대표적으로 MSA, 공간 기반 아키텍쳐가 있다.  
  그 밖에도 이벤트 기반 마이크로커널 아키텍쳐, 이벤트 기반 파이프라인 아키텍쳐도 있다.

- 어떤 아키텍쳐 스타일이든 이벤트 기반 아키텍쳐를 추가하면 병목 지점을 제거하고 이벤트 요청을 백업하는 배압 지점(backpressure point)을  
  확보하는 데 유용하며, 다른 아키텍쳐 스타일에서는 찾아볼 수 없는 유저 응답성이 보장된다. MSA, 공간 기반 아키텍쳐는 데이터 펌프에  
  메시징을 활용하며, 다른 프로세서에 데이터를 비동기 전송해 데이터베이스의 데이터를 업데이트한다. 또한 서비스 간에 메시지를 주고받으며  
  통신할 때 MSA의 서비스와 공간 기반 아키텍쳐의 처리장치 모두 이벤트 기반 아키텍쳐를 활용함으로써 프로그래밍 방식의 확장성을 달성할 수 있다.₩
