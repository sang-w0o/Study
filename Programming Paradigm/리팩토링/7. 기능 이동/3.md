## 문장 슬라이드하기

```js
// 리팩토링 적용 전
const pricingPlan = retrievePricingPlan();
const order = retriveOrder();
let charge;
const chargePerUnit = pricingPlan.unit;

// 리팩토링 적용 후

const pricingPlan = retrievePricingPlan();
const chargePerUnit = pricingPlan.unit;
const order = retriveOrder();
let charge;
```

### 배경

- 관련된 코드들이 가까이 모여 있다면 이해하기가 더 쉽다. 예를 들어, 하나의 데이터 구조를  
  이용하는 문장들은 다른 데이터를 이용하는 코드 사이에 흩어져 있기보다는 한데 모여 있어야  
  좋다. 실제로 이 리팩토링으로 이런 코드들을 한데 모으자. 가장 흔한 사례는 변수를  
  선언하고 사용할 때다. 모든 변수 선언을 함수 첫머리에 모아 두는 사람도 있는데,  
  변수를 처음 사용할 때 선언하는 것도 좋다.

- 관련 코드끼리 모으는 작업은 다른 리팩토링(주로 **함수 추출하기**)의 준비 단계로 자주  
  행해진다. 관련 있는 코드들을 명확히 구분되는 함수로 추출하는 게 그저 문장들을 한데로  
  모으는 것보다 나은 분리법이다. 하지만 코드들이 모여있지 않다면 함수 추출은 애초에  
  수행할 수조차 없다.

### 절차

- (1) 코드 조각(문장들)을 이동할 목표 위치를 찾는다. 코드 조각의 원래 위치와 목표 위치  
  사이의 코드들을 훑어보면서, 조각을 모으고 나면 동작이 달라지는 코드가 있는지 확인한다.  
  아래와 같은 간섭이 있다면 이 리팩토링은 포기한다.

  - 코드 조각에서 참조하는 요소를 선언하는 문장 앞으로는 이동할 수 없다.
  - 코드 조각을 참조하는 요소의 뒤로는 이동할 수 없다.
  - 코드 조각에서 참조하는 요소를 수정하는 문장을 건너뛰어 이동할 수 없다.
  - 코드 조각이 수정하는 요소를 참조하는 요소를 건너뛰어 이동할 수 없다.

- (2) 코드 조각을 원래 위치에서 잘라내어 목표 위치에 붙여넣는다.
- (3) 테스트한다.

- 테스트가 실패한다면 더 작게 나눠 시도해보자. 이동 걸이를 줄이는 방법과 한 번에 옮기는  
  조각의 크기를 줄이는 방법이 있다.

### 예시

- 코드 조각을 슬라이드할 때는 두 가지를 확인해야 한다. **무엇을 슬라이드할지**와  
  **슬라이드할 수 있는지 여부**이다. 무엇을 슬라이드할지는 맥락과 관련이 깊다.  
  가장 단순하게는, 요소를 선언하는 곳과 사용하는 곳을 가까이 두고 싶다면, 선언 코드를  
  슬라이드하여 처음 사용하는 곳까지 끌어내릴 수 있다. 그 외에도 다른 리팩토링을 하기 위해서는  
  거의 항상 코드를 슬라이드하게 된다. 예를 들어, **함수 추출하기** 전에 추출할 코드를  
  한데 모을 때 적용할 수 있다.

- 코드 조각을 슬라이드하기로 했다면, 다음 단계로는 그 일이 실제로 가능한지를 결정해야 한다.  
  그려려면 슬라이드할 코드 자체와 그 코드가 건너뛰어야할 코드를 모두 살펴야 한다.  
  이 코드들의 순서가 바뀌면 프로그램의 겉보기 동작이 달라질까?

- 아래 코드를 예시로 보자.

```js
/* (1) */ const pricingPlan = retrievePricingPlan();
/* (2) */ const order = retrieveOrder();
/* (3) */ const baseCharge = pricingPlan.base;
/* (4) */ let charge;
/* (5) */ const chargePerUnit = pricingPlan.unit;
/* (6) */ const units = order.units;
/* (7) */ let discount;
/* (8) */ charge = baseCharge + chargePerUnit * units;
/* (9) */ let discountableUnits = Math.max(
  units - pricingPlan.discountThreshold,
  0
);
/* (10) */ discount = discountableUnits * pricingPlan.discountFactor;
/* (11) */ if (order.isRepeat) discount += 20;
/* (12) */ charge = charge - discount;
/* (13) */ chargeOrder(charge);
```

- 처음 일곱 줄은 선언이므로 이동하기가 상대적으로 쉽다. 예를 들어, 할인 관련 코드를 한데 모으고  
  싶다면 7번째 줄을 10번째 줄 바로 위까지 내리면 된다. 선언은 부수효과가 없고 다른 변수를  
  참조하지도 않으므로 discount 자신을 참조하는 첫 번째 코드 바로 앞까지는 어디로든 옮겨도 안전하다.  
  이런 이동은 여러 상황에서 공통적으로 이뤄진다. 예를 들어, 할인 로직을 별도의 **함수로 추출**하고  
  싶다면, 추출하기 전에 이 선언의 위치부터 옮겨줘야 한다.

- 부수효과가 없는 다른 코드에도 비슷한 분석을 수행해보면, 2번째 줄도 6번째 줄 바로 위로 옮겨도  
  문제가 없음을 알 수 있다.

- 이 경우 건너뛰어지는 코드들도 부수효과가 없다는 점이 도움이 됐다. 사실 부수효과가 없는  
  코드끼리는 마음 가는 대로 재배치할 수 있다. 현명한 개발자들이 되도록 부수효과 없는 코드들로  
  프로그래밍하는 이유 중 하나다.

- 여기서 짚고 넘어가야 할 게 있다. 2번 줄이 부수효과가 없다는 것을 어떻게 알았을까?  
  확실히 하려면 `retrieveOrder()`의 내부, 그리고 그 안에서 호출되는 모든 함수의 내부도  
  모두 살펴 아무 부수효과가 없음을 확인해야 한다. 하지만 만약 명령-쿼리 조회 원칙을 지켜가며  
  개발했다면, 값을 반환하는 함수가 부수효과가 없음을 확신할 수 있다. 단, 코드베이스에 대해 잘  
  알때만 이 점을 확신할 수 있다. 잘 모르는 코드베이스에서 작업한다면 더욱 주의해야 한다.  
  어쨋든 사용자는 코드가 부수효과가 없음을 안다는 것의 가치는 매우 크므로, 항상 명령-쿼리  
  조회 원칙을 지키려 노력하자.

- 부수효과가 있는 코드를 슬라이드하거나 부수효과가 있는 코드를 건너뛰어야 한다면 훨씬 신중해야 한다.  
  두 코드 조각 사이에 간섭이 있는지를 확인해야 한다. 예를 들어 11번째 줄을 코드 맨 끝으로  
  슬라이드 하고 싶다 해보자. 이 작업은 12번째 줄 `if(order.isRepeat) /..` 때문에 막히는데,  
  11번째 줄에서 상태를 수정한 변수 discount를 12번째 줄에서 참조하기 때문이다.  
  비슷하게, 13번 줄도 12번 줄 앞으로 이동시킬 수 없다. 하지만 8번 줄은 9~11번 줄을  
  건너뛸 수 있다. 이 코드들에서는 공통된 상태를 수정하는 일이 전혀 없기 때문이다.

- 슬라이드할 코드 조각과 건너뛸 코드 중 어느 한쪽이 다른 쪽에서 참조하는 데이터를 수정한다면  
  슬라이드를 할 수는 없다. 이것이 가장 직관적인 규칙이다. 하지만 완벽한 규칙은 아닌 것이,  
  아래 두 줄은 순서를 바꿔도 안전하다.

```js
a = a + 10;
a = a + 5;
```

- 슬라이드가 안전한지를 판단하려면 관련된 연산이 무엇이며, 어떻게 구성되는지를  
  완벽히 이해해야 한다.

- 상태 갱신에 특히나 신경 써야 하기에 상태를 갱신하는 코드 자체를 최대한 제거하는 게 좋다.  
  그래서 위 코드에 어떤 다른 슬라이드를 시도하기에 앞서, charge 변수를 쪼개보자.

- 지금 예시에서는 지역 변수만 수정하고 있으니 분석하기가 상대적으로 쉽다. 데이터 구조가 더  
  복잡했다면 간섭 여부를 확신하기가 훨씬 어려웠을 것이다. 그래서 테스트가 중요한 역할을  
  한다. 조각을 슬라이드한 후 테스트를 수행해서 깨지는게 없는지 확인하자. 테스트 커버리지가  
  높다면 맘놓고 리팩토링할 수 있다. 테스트를 믿을 수 없다면 이 리팩토링을 더 신중하게 진행한다.  
  혹은 더 흔하게는 당장의 리팩토링에 영향받는 코드의 테스트를 보강한다.

- 슬라이드 후 테스트가 실패했을 때 가장 좋은 대처는 더 작게 슬라이드해 보는 것이다.  
  열 줄을 건너뛰는 대신 다섯 줄만 건너뛰거나, 위험해 보이는 줄까지만 슬라이드해보자.  
  테스트 실패는 그 슬라이드를 수행할 가치가 없거나 다른 무언가를 먼저 하라는 뜻일 수도 있다.

### 예시: 조건문이 있을 때의 슬라이드

- 조건문의 안팎으로 슬라이드해야 할 때도 있다. 조건문 밖으로 슬라이드할 때는 중복 로직이  
  제거될 것이고, 조건문 안으로 슬라이드할 때는 반대로 중복 로직이 추가될 것이다.

- 아래 조건문의 두 분기에는 똑같은 문장이 포함돼 있다.  
  `allocatedResources.push(result);`

```js
let result;
if (availableResources.length === 0) {
  result = createResource();
  allocatedResources.push(result);
} else {
  result = availableResources.pop();
  allocatedResources.push(result);
}
return result;
```

- 이때 중복된 문장들을 조건문 밖으로 슬라이드할 수 있는데, 조건문 블록 밖으로  
  꺼내는 순간 한 문장으로 합쳐져 중복이 제거된다.

```js
let result;
if (availableResources.length === 0) {
  result = createResource();
} else {
  result = availableResources.pop();
}
allocatedResources.push(result);
return result;
```

- 반대 상황, 즉 코드 조각을 조건문 안으로 슬라이드하면 조건문의 모든 분기에 복제되어 들어간다.

<hr/>
