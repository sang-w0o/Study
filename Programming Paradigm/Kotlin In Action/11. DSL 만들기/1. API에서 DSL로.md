# API에서 DSL로

- DSL에 대해 보기 전에, 우리가 해결하려 하는 문제에 대해 더 자세히 알아보자. 궁극적인 목표는 코드의 가독성과 유지보수성을  
  가장 좋게 유지하는 것이다. 그런 목표를 달성하려면 개별 클래스에 집중하는 것만으로는 충분하지 않다. 클래스에 있는 코드 중  
  대부분은 다른 클래스와 상호작용한다. 따라서 그런 상호작용이 일어나는 연결 지점(interface)을 살펴봐야 한다.  
  즉, 클래스의 API를 살펴봐야 한다는 것이다.

- 라이브러리를 만드는 사람들에게만 API를 훌륭하게 만들 책임이 있는 것이 아니라는 사실이 중요하다. 사실 모든 개발자는 API를  
  훌륭하게 만들기 위해 노력해야 한다. 라이브러리가 외부 사용자에게 프로그래밍 API를 지원하는 것처럼 애플리케이션 안의 모든  
  클래스는 다른 클래스에게 자신과 상호작용할 수 있는 가능성을 제공한다. 이런 상호작용을 이해하기 쉽고 명확하게 표현할 수 있어야  
  프로젝트를 쉽게 계속 유지 보수할 수 있다.

- 지금까지 이 책에서 클래스를 위한 API를 깔끔하게 작성할 수 있게 도와주는 여러 코틀린 특성을 살펴보았다.  
  그렇다면 _API가 깔끔하다_ 는 말은 말은 어떤 뜻일까? 이 말에는 아래의 두 가지 뜻이 있다.

  - 코드를 읽는 독자들이 어떤 일이 벌어질지 명확히 이해할 수 있어야 한다. 이름과 개념을 잘 선택하면 이런 목적을 달성할 수 있다.  
    어떤 언어를 사용하든 이름을 잘 붙이고 적절한 개념을 사용하는 것은 매우 중요하다.

  - 코드가 간결해야 한다. 불필요한 구문이나 번잡한 준비 코드가 가능한 한 적어야 한다.  
    깔끔한 API는 언어에 내장된 기능과 거의 구분할 수 없다.

- 아래 표는 코틀린이 _간결한 구문_ 을 어떻게 제공하는지의 예시를 담은 것이다.

| 일반 구문                        | 간결한 구문                             | 사용한 언어 특성               |
| :------------------------------- | --------------------------------------- | ------------------------------ |
| `StringUtil.capitalize(s)`       | `s.capitalize()`                        | 확장 함수                      |
| `l.to("one")`                    | `l to "one"`                            | 중위 호출                      |
| `set.add(2)`                     | `set += 2`                              | 연산자 오버로딩                |
| `map.get("key")`                 | `map["key"]`                            | `get()` 메소드에 대한 관례     |
| `file.use((f -> f.read()))`      | `file.use { it.read() }`                | 람다를 괄호 밖으로 빼내는 관례 |
| `sb.append("a"); sb.append("b")` | `with(sb) { append("a"); append("b") }` | 수신 객체 지정 람다            |

- 여기서는 깔끔한 API에서 한걸음 더 나아가 DSL 구축을 도와주는 코틀린 기능을 살펴본다.  
  코틀린 DSL은 간결한 구문을 제공하는 기능과 그런 구문을 확장해 여러 메소드의 호출을 조합함으로써 구조를 만들어내는 기능에 의존한다.  
  그 결과로 DSL은 메소드 호출만을 제공하는 API에 비해 더 표현력이 풍부하고 사용하기 편해진다.

- 코틀린 언어의 다른 특성과 마찬가지로, 코틀린 DSL도 온전히 컴파일 시점에 타입이 정해진다. 따라서 컴파일 시점 오류 감지, IDE 지원 등 모든  
  정적 타입 지정 언어의 장점을 코틀린 DSL을 사용할 때도 누릴 수 있다.

- 예시로 코틀린 DSL이 할 수 있는 일을 몇 가지 살펴보자.  
  아래 식은 시간을 되돌려서 하루 전 날을 반환한다.

```kt
val yesterday = 1.days.ago
```

- 아래 함수는 HTML Table을 생성한다.

```kt
fun createSimpleTable = createHTML().
	table {
		tr {
			td { +"cell" }
		}
	}
```

- 이 장에서는 위와 같은 예제들을 어떻게 구현하는지 살펴본다.  
  구현 부분을 보기 전에, 먼저 DSL이 무엇인지부터 알아보자.

---

## DSL: Domain Specific Language

- DSL이라는 개념은 프로그래밍 언어라는 개념과 거의 마찬가지로 오래된 개념이다. 우리는 컴퓨터가 발명된 초기부터 컴퓨터로 풀 수 있는 모든 문제를 충분히  
  풀 수 있는 기능을 제공하는 **범용 프로그래밍 언어(general-purpose programming language)** 와 특정 과업 또는 영역에 초점을 맞추고 그  
  영역에 필요하지 않은 기능을 없앤 **영역 특화 언어**를 구분해왔다.

- 일반 사람들에게 가장 익숙한 DSL로는 SQL과 정규식이 있다. 이 두 언어는 데이터베이스 조작과 문자열 조작이라는 특정 작업에 가장 적합하다.  
  하지만 전체 애플리케이션을 정규식이나 SQL로 작성하는 경우는 없다.

- 이런 DSL이 스스로 제공하는 기능을 제한함으로써 오히려 더 효율적으로 자신의 목표를 달성할 수 있다는 점을 생각해보자.  
  SQL문을 실행할 필요가 있는 경우, 클래스나 함수를 선언하는 것부터 시작할 필요가 없다. 대신 모든 SQL문장은 첫 키워드가 수행하려는  
  연산의 종류를 지정하고, 각 연산은 처리해야 할 작업에 맞춰 각각 서로 다른 문법과 키워드를 사용한다. 정규식 언어의 경우 문법은 훨씬 더 단순하다.  
  정규식 프로그램은 압축적인 기호 문법을 사용해 텍스트가 어떻게 달라질 수 있는지를 지정함으로써 대상 텍스트를 직접 기술한다.  
  이런 압축적인 문법을 사용함으로써 DSL은 범용 언어를 사용하는 경우보다 특정 영역에 대한 연산을 더 간결하게 기술할 수 있다.

- 그리고 DSL이 범용 프로그래밍 언어와 달리 더 **선언적(declarative)** 이라는 점이 중요하다. 범용 프로그래밍 언어는 보통  
  **명령적(imperative)** 이다. 명령적 언어는 어떤 연산을 완수하기 위해 필요한 각 단계를 순서대로 기술하는 반면, 선언적 언어는 원하는  
  결과를 기술하기만 하고 그 결과를 달성하기 위해 필요한 세부 실행은 언어를 해석하는 엔진에게 맡긴다. 실행 엔진이 결과를 얻는 과정을 전체적으로  
  한꺼번에 최적화하기 때문에 선언적 언어가 더 효율적인 경우가 자주 있다. 반면 명령적 접근법에서는 각 연산에 대한 구현을 독립적으로 최적화해야 한다.

- 하지만 DSL에도 단점은 있다. 그 단점은 바로 DSL을 범용 언어로 만든 host application과 함께 조합하기가 어렵다는 점이다.  
  DSL은 자체 문법이 있기에 다른 언어의 프로그램 안에 직접 포함시킬 수가 없다. 따라서 DSL로 작성한 프로그램을 다른 언어에서 호출하려면  
  DSL 프로그램을 별도의 파일이나 문자열 리터럴로 작성해야 한다. 하지만 이런식으로 DSL을 저장하면 host program과 DSL의 상호작용을  
  컴파일 시점에 제대로 검증하거나, DSL 프로그램을 디버깅하거나, DSL 코드 작성을 돕는 IDE 기능을 제공하기 어려워진다는 문제가 있다.  
  또한 DSL과 host 언어의 문법이 서로 다르므로 두 언어를 함께 배워야 하고, 코드를 읽기가 어려워지는 경우도 있다.

- 이러한 문제들을 해결하면서 DSL의 다른 이점은 살리는 방법으로 **Internal DSL** 이라는 개념이 점점 유명해지고 있다.

---

## Internal DSL

- 독립적인 문법 구조를 가진 External DSL과는 반대로 Internal DSL은 범용 언어로 작성된 프로그램의 일부이며, 범용 언어와 동일한 문법을 사용한다.  
  따라서 internal DSL은 완전히 다른 언어가 아니라 DSL의 핵심 장점을 유지하면서 주 언어를 특별한 방법으로 사용하는 것이다.

- 두 접근법을 비교하기 위해 같은 파일을 internal, external DSL로 각각 작성하는 예시를 살펴보자.  
  `Customer`와 `Country`라는 두 개의 테이블이 있고, 각 `Customer`에는 고객이 살고 있는 나라에 대한 참조(`Country`의 PK에 대해)가 있다 하자.  
  목표는 가장 많은 고객이 살고 있는 나라를 알아내는 것이다. External DSL로는 SQL을 사용하며, DSL로는 코틀린으로 작성된 데이터베이스 프레임워크인  
  Exposed 프레임워크를 사용한다. 아래는 SQL을 사용한 구현이다.

```sql
SELECT Country.name, COUNT(Customer.id)
  FROM Country
  JOIN Customer
    ON Country.id = Customer.country_id
  GROUP BY Country.name
  ORDER BY COUNT(Customer.id) DESC
  LIMIT 1;
```

- SQL과 주 애플리케이션 언어(코틀린) 사이에 상호작용할 수 있는 방법을 제공해야 하기에 SQL로 코드를 작성하는 것이 편하지 않다.  
  보통 최선의 수단은 SQL을 문자열 리터럴에 넣고 SQL 작성과 검증을 IDE가 도와주기를 바라는 것이다.

- 코틀린과 Exposed를 사용해 같은 query를 구현한 예시를 보자.

```kt
(Country join Customer)
  .slice(Country.name, Count(Cutomer.id))
  .selecAll()
  .groupBy(Country.name)
  .orderBy(Count(Customer.id), isAsc = false)
  .limit(1)
```

- 위 두 코드 예시에서 비슷한 점을 찾을 수 있다. 사실 두 번째 코드는 첫 번째 SQL문과 완전히 동일한 query를 수행한다.  
  하지만 두 번째 코드는 일반 코틀린 코드이며 `selectAll()`, `groupBy()`, `orderBy()` 등 일반 코틀린 메소드를 사용한다.  
  더 나아가 두 번째 코드에서는 SQL 질의가 돌려주는 결과 집합을 코틀린 객체로 변환하기 위해 노력할 필요가 없다.  
  query를 실행한 결과가 네이티브 코틀린 객체이기 때문이다. 따라서 두 번째 버전을 Internal DSL이라 한다.  
  코드는 어떤 구체적인 과업을 달성(SQL Query 생성)하기 위한 것이지만, 범용 언어(코틀린)의 라이브러리로 구현된다.

---

## DSL의 구조

- DSL과 일반 API 사이에 잘 정의된 일반적인 경계는 없다. DSL은 중위 호출이나 연산자 오버로딩 같이 다른 문맥에서도 널리 쓰이는 언어 기능에  
  의존하기도 한다. 하지만 다른 API에는 존재하지 않지만 DSL에만 존재하는 특징이 한 가지 있다. 바로 구조 또는 문법이다.

- 전형적인 라이브러리는 여러 메소드로 이뤄지며, 클라이언트는 그런 메소드를 한 번에 하나씩 호출함으로써 라이브러리를 사용한다.  
  함수 호출 시퀀스에는 아무런 구조가 없으며, 한 호출과 다른 호출 사이에는 아무 맥락도 존재하지 않는다. 그런 API를 때때로  
  command-query API라고 한다. 반대로 DSL의 메소드 호출은 DSL 문법에 의해 정해지는 더 커다란 구조에 속한다.  
  코틀린 DSL에서는 보통 람다를 중첩시키거나 메소드 호출을 chaining하는 방식으로 구조를 만든다. 그런 구조를 위에서 본 SQL 예시에서도  
  살펴볼 수 있다. query를 수행하려면 필요한 결과 집합의 여러 측면을 기술하는 메소드 호출을 조합해야 하며, 그렇게 메소드를 조합해 만든  
  query는 query에 필요한 인자를 메소드 호출 하나에 모두 다 넘기는 것보다 훨씬 더 읽기 쉽다.

- 이런 문법이 있기에 Internal DSL을 언어라고 부를 수 있다. 영어와 같은 자연어에서는 단어가 문장을 구성하고 문법 규칙은 단어가 모여서  
  문장을 만드는 방식을 규정한다. 마찬가지로 DSL에서는 여러 함수 호출을 조합해 연산을 만들며, 타입 검사기는 여러 함수 호출이 바르게  
  조합됐는지 검사한다. 결과적으로 함수명은 보통 동사(`groupBy`, `orderBy`) 역할을 하고, 함수 인자는 명사(`Country.name`) 역할을 한다.

- DSL 구조의 장점은 같은 문맥을 함수 호출시마다 반복하지 않고도 재사용할 수 있다는 점이다.  
  Gradle에서 Dependency를 정의할 때 사용하는 코틀린 DSL인 아래 코드는 이 사실을 보여준다.

```kt
dependencies {
  compile("A")
  compile("B")
}
```

- 반대로 아래는 일반 command-query API를 통해 같은 일을 하는 코드다. 코드에 중복이 더 많다는 사실을 알 수 있다.

```kt
project.dependencies.add("compile", "A")
project.dependencies.add("compile", "B")
```

- 메소드 호출 chaining은 DSL 구조를 만드는 또다른 방법이다. 예를 들어 테스트 프레임워크에서 assertion을 여러 메소드 호출로 나눠  
  작성하는 경우가 많다. 그런 assertion은 훨씬 더 읽기 쉽다. 특히 중위 호출 구문을 사용하면 가독성이 더 좋아진다.  
  코틀린을 위한 third party test framework인 kotlintest의 예시를 보자.

```kt
str should startWith("kot")
```

- 일반 JUnit API를 사용해 같은 테스트를 작성하면 아래처럼 된다.

```kt
assertTrue(str.startsWith("kot"))
```

---
