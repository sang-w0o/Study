# 헥사고날 아키텍쳐와 클린 아키텍쳐

<h2>계층형 아키텍쳐</h2>

- Layered(계층형) 아키텍쳐를 구성하는 Layer는 많은 사람들이 혼동하는 물리적인 티어의 개념과 달리  
  논리적인 개념이다. 티어는 물리적인 장비나 서버 컴퓨터 등의 물리층을 의미하고, 레이어는  
  내부의 논리적인 분할을 의미한다.

- 물리적인 서버 티어의 계층을 살펴보면, 아래와 같다.

  - Presentation(상위)
  - Business Logic
  - Data Access(하위)

- 계층은 설계자들이 복잡한 시스템을 분리할 때 흔히 사용하는 패턴 중 하나로, 애플리케이션이 내부에서 처리하는  
  관심사를 논리적으로 구분한다.

- Presentation Layer의 관심사는 *화면 표현 및 전환 처리*이고, Business Logic의 관심사는  
  *비즈니스 개념 및 규칙, 흐름 제어*이며 Data Access의 관심사는 *데이터 처리*이다.  
  계층형 아키텍쳐는 계층 간의 응집성은 높이고 의존성은 낮추기 위해 아래와 같은 몇 가지 규칙을 둔다.

  - 상위 계층이 하위 계층을 호출하는 단방향성을 유지한다.
  - 상위 계층은 하위의 여러 계층을 알 필요 없이 바로 밑의 근접 계층만 활용한다.
  - 상위 계층이 하위 계층에 영향을 받지 않게 구성해야 한다.
  - 하위 계층은 자신을 사용하는 상위 계층을 알지 못하게 구성해야 한다.
  - 계층 간의 호출은 인터페이스를 통해 호출하는 것이 바람직하다.(구현 클래스에 직접 의존 X => 약한 결합 유지)

- 특히 인터페이스를 통한 의존성 분리는 인터페이스를 구현하는 구현체를 다양하게 해주는 다형성을 추구함으로써  
  제어 흐름을 간접적으로 전환하게 해준다.

- 일반적인 계층형 아키텍쳐는 DIP(의존성 역전 원칙)은 만족한다.
  하지만 OCP(개방 폐쇄의 원칙)은 만족하지 않는다.  
  일반적인 계층형 아키텍쳐가 OCP에 위반되는 이유는 모든 계층이 각기 자신이 제공하는 기능에 대한  
  추상적인 인터페이스를 직접 정의하고 소유하기 때문이다. 이런 구조에서는 구조의 흐름이 상위 계층에서 하위 계층으로  
  흐르게 되며, 이에 따른 소스코드의 의존성은 제어 흐름의 방향대로 따를 수밖에 없다.

  > DIP(Dependency Inversion Principle): 소스코드는 추상에 의존하며, 구체에는 의존하지 않는다.  
  > OCP(Open-Closed Principle): 객체는 변경에는 닫혀있고 확장에는 열려 있다.

- 물론 상위 계층은 하위 계층의 구체 클래스가 아니라 추상 인터페이스에 의존하고, 그 인터페이스의 구현체를 달리하는  
  방법으로 의존성을 줄이고 다형성은 유지할 수 있으나, 인터페이스는 그 계층이 정의하는 추상 특성의  
  한계를 벗어날 수 없다.

- 따라서 하위 계층의 유형이 추가되어 확장될 때 닫혀 있어야 할 상위 계층이 하위 계층에서 정의한 특성에  
  영향을 받게 된다.

- 위에서 본 계층형 아키텍쳐의 규칙을 보면, 가장 하위에 있는 Data Access 계층이 변경됐을 때 Business Logic 계층은  
  변경되면 안된다. 만약 Data Access 계층의 인터페이스가 완전히 변경된다면 Business Logic 계층의 클래스가  
  Data Access 계층의 인터페이스에 의존하기에 변경의 영향을 받을 수밖에 없다.

- 즉, 문제는 Data Access 인터페이스의 위치이다. Data Access 인터페이스는 Data Access 계층에 위치한다.  
  당연해 보이지만, 이 위치 때문에 상위 계층이 하위 계층에 의존하게 된다.

- 애플리케이션에서는 비즈니스 로직이 핵심 영역이다. 그렇기에 비즈니스 로직을 보통 *고수준 영역*이라 하고, Presentation 및  
  Data Access 계층을 *저수준 영역*이라 한다. 고수준 영역은 핵심 영역이기에 보호를 받아야 하고, 따라서 저수준 영역의 변경이나  
  확장에 영향을 받지 말아야 한다. 그러나 일반적인 계층형 아키텍쳐의 규칙만 따른다면, 고수준 영역이 저수준 영역에 의존하게 되고  
  영향을 받게 된다.

- 여기서 의존성 역전 원칙(DIP)을 제대로 적용할 필요가 생긴다. DIP를 통해 Data Access 계층에서 정의한 인터페이스를  
  비즈니스 로직 계층으로 옮긴다. 그러면 Data Access 계층의 구현체는 비즈니스 로직 계층의 인터페이스를 바라볼 수밖에 없다.

- 즉, Data Access 계층이 구현해야할 인터페이스를 좀 더 고수준의 비즈니스 로직 계층에서 정의하게 함으로써  
 기존의 위에서 아래로 흘렀던 의존 관계를 역전시키고, 고수준 영역이 저수준 영역의 변경에 영향을 받지 않게 하는 것이다.
<hr/>

<h2>Hexagonal 아키텍쳐</h2>

- 위처럼 계층형 아키텍쳐에 DIP를 적용해도 한계가 있다. Presentation 계층과 Data Access 계층을 보통 저수준 영역이라고  
  한다고 했는데, 현대 애플리케이션에서는 이러한 두 가지 계층 말고도 다양한 인터페이스를 필요로 한다.  
  즉, 애플리케이션을 호출하는 다양한 시스템의 유형과 애플리케이션과 상호작용하는 다양한 저장소가 존재한다.  
  단방향 계층구조에서는 이러한 점을 지원하기 힘들다. 다방면으로 열려 있는 헥사고날(Hexagonal) 아키텍쳐는 이러한  
  문제점을 해결할 수 있다.

- Hexagonal 아키텍쳐는 다른 말로 Ports and Adapters Architecture라고도 한다.  
  Hexagonal 아키텍쳐에서는 고수준의 비즈니스 로직을 표현하는 `내부 영역`과 인터페이스 처리를 담당하는 저수준의 `외부 영역`으로  
  나눈다. 내부 영역은 순수한 비즈니스 로직을 표현하는 기술에 독립적인 영역이다. 그리고 외부 영역과 연계되는 Port를  
  가지고 있다. 외부 영역은 외부에서 들어오는 요청을 처리하는 Inbound Adapter와 비즈니스 로직(내부 영역)에 의해  
  호출되어 외부와 연계되는 Outbound Adapter로 구성된다.

- 이러한 Hexagonal 아키텍쳐의 가장 큰 특징은 고수준의 내부 영역이 **외부의 구체 어댑터에 전쳐 의존하지 않게 한다**는 것이다.  
  이를 가능하게끔 하는 것이 내부 영역에 구성되는 Port이다.

- Port는 Inbound Port와 Outbound Port로 구분되는데, Inbound Port는 내부 영역의 사용을 위해 표출된 API 이며,  
  외부 영역의 Inbound Adapter가 호출한다. Outbound Port는 내부 영역이 외부를 호출하는 방법을 정의한다.  
  여기서 DIP 원칙과 같이 Outbound Port가 외부의 Outbound Adapter를 호출해서 외부 시스템과 연계하는 것이 아니라  
  Outbound Adapter가 Outbound Port에 의존해서 구현된다.

- 외부 영역에 존재하는 어댑터의 종류를 살펴보면 Inbound Adapter로는 REST API를 발행하는 Controller,  
  웹 페이지를 구성하는 Spring MVC Controller, Command Handler, Event Message Subscribe Handler등이  
  될 수 있고, Outbound Adapter로는 Data Access 처리를 담당하는 DAO, Event Message를 발행하는 클래스,  
  외부 서비스를 호출하는 Proxy 등이 될 수 있다.

> Hexagonal Architecture는 육각형의 모양으로 구성되며, 아래의 관계를 갖는다.
> `웹` => 외부 영역의 `Inbound Adapter` => 외부 영역 => `Inbound Port` => 내부 영역의 비즈니스 로직
> 내부 영역의 비즈니스 로직 => `Outbound Port` => 외부 영역 => 외부 영역의 `Outbound Adapter` => 웹

<hr/>

<h2>Clean Architecture</h2>

- Clean Architecture는 저명한 Robert C. Martin이 제안한 아키텍쳐로서, Hexagonal Architecture의 아이디어와  
  매우 유사하다.

- 이 아키텍쳐는 소프트웨어를 _부드럽게 유지_ 하는 방법에 집중하는데, 이를 실현하기 위한 방법은  
  **구조 중에서 선택할 수 있는 것을 가능한 한 오랫동안 열어두는 것**이다.  
  특히 열어둬야 할 선택사항은 바로 중요하지 않은 세부사항이다.

- Clean Architecture는 여러 겹으로 둘러싸인 영역으로 표현되며,  
  중앙에서 밖으로 Entity, Use Case, 그 외 세부사항으로 구분된다.

- 정중앙에는 `Entity`가 있다. `업무 규칙`은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차를 말한다.  
  이러한 업무 규칙은 수동으로 처리할 수 있지만, 시스템으로도 자동화할 수 있다.  
  예를 들면 쇼핑몰의 물건을 사고 파는 규칙, 은행의 이자 계산 규칙, 도서대출 시스템의 대출, 반납 규칙 등 모든 시스템에는  
  해당 도메인의 업무를 규정하는 **핵심 업무 규칙**이 존재한다.  
  그리고 이 핵심 업무 규칙은 보통 데이터를 요구한다. 따라서 핵심 규칙과 데이터는 본질적으로 결합되어 있기 때문에  
  객체로 쉽게 만들 수 있다. 이러한 유형을 Entity라 한다.

- 그 다음으로 Entity를 감싸는 객체는 `Use Case`이다. Use Case는 자동화된 시스템을 사용하는 처리 절차를 의미한다.  
  Use Case는 애플리케이션에 특화된 업무 규칙을 표현하며, Entity 내부의 핵심 업무 규칙을 호출하며  
  시스템을 사용하는 흐름을 담는다. 이때 Entity같은 고수준 영역은 저수준의 Use Case 영역을 알게 해서는 안된다.  
  Entity는 간단한 객체여야 하며, 프레임워크 데이터베이스 또는 기타 복잡한 것에 의존해서는 안되고  
  Use Case 객체를 통해서만 조작해야 한다.

- 그리고 그 다음으로 Use Case를 감싸고 있는 나머지 모든 영역이 `세부 사항`이다.  
 세부 사항으로는 입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등이 될 수 있으며,  
 세부사항과 Use Case의 관계를 DIP원칙을 이용해 플러그인처럼 유연하게 처리해야 한다.  
 이처럼 명확한 결합의 분리는 테스트의 용이성 및 개발 독립성, 배포 독립성을 강화할 수 있다.
<hr/>
