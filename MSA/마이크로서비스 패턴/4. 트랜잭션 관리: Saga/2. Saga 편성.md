# Saga 편성

- Saga는 단계를 편성하는 로직으로 구성된다. 시스템 커맨드가 Saga를 시작할 때  
  이 편성 로직은 첫 번째 Saga 참여자를 정하여 로컬 트랜잭션 실행을 지시하고,  
  트랜잭션이 완료되면 그 다음 Saga 참여자를 호출하는 과정이 모든 단계가 실행될  
  때까지 반복된다. 도중 하다라도 로컬 트랜잭션이 실패하면, Saga는 보상 트랜잭션을  
  역순으로 실행한다. Saga 편성 로직은 두 가지 종류가 있다.

  - **코레오그래피(Choreography)** : 의사 결정과 순서화를 Saga 참여자에게  
    맡긴다. Saga 참여자는 주로 이벤트 교환 방식으로 통신한다.
  - **오케스트레이션(Orchestration)** : Saga 편성 로직을 Saga 오케스트레이터에  
    중앙화한다. Saga 오케스트레이터는 Saga 참여자에게 커맨드 메시지를 보내  
    수행할 작업을 지시한다.

<h2>코레오그래피 Saga</h2>

- 코레오크래피 방식은 Saga 참여자에게 할 일을 알려주는 중앙 편성자가 없다.  
  그 대신 Saga 참여자가 서로 이벤트를 구독해서 그에 따라 반응하게 한다.

<h3>주문 생성 Saga 구현: 코레오그래피 스타일</h3>

- 코레오그래피 스타일로 주문 생성 Saga를 설계해보자. Saga 참여자는 서로 이벤트를  
  주고받으며 소통한다. 주문 서비스를 시작으로 각 참여자는 자신의 DB를 업데이트하고  
  다음 참여자를 트리거하는 이벤트를 발행한다.

- 별 문제가 없다면 아래 순서대로 진행될 것이다.

  - (1) 주문 서비스: 주문을 `APPROVAL_PENDING` 상태로 생성 => _주문 생성_ 이벤트 발행
  - (2) 소비자 서비스: _주문 생성_ 이벤트 수신 => 소비자가 주문 가능한지 확인 =>  
    _소비자 확인_ 이벤트 발행
  - (3) 주방 서비스: _주문 생성_ 이벤트 수신 => 주문 내역 확인 => 티켓을 `CREATE_PENDING`  
    상태로 생성 => _티켓 생성됨_ 이벤트 발행
  - (4) 회계 서비스: _주문 생성_ 이벤트 수신 => 신용카드 승인을 `PENDING` 상태로 생성
  - (5) 회계 서비스: _티켓 생성됨_ 및 _소비자 확인_ 이벤트 수신 => 소비자 신용카드 과금 =>  
    _신용카드 승인됨_ 이벤트 발행
  - (6) 주방 서비스: _신용카드 승인됨_ 이벤트 수신 => 티켓 상태를 `AWAITING_ACCEPTANCE`로 변경
  - (7) 주문 서비스: _신용카드 승인됨_ 이벤트 수신 => 주문 상태를 `APPROVED`로 변경 =>  
    _주문 승인됨_ 이벤트 발행

- 주문 생성 Saga는 어떤 Saga 참여자가 주문을 거부해서 실패 이벤트가 발행되는 경우  
  (소비자 신용카드 승인 거부 등)를 대비해야 한다. 이런 일이 발생하면 Saga는 어떻게든 보상 트랜잭션을  
  가동하여 이미 수행한 작업을 undo 해야 한다. 예를 들어, 회계 서비스에서 소비자 신용카드가  
  승인 거부된 경우, 이벤트 순서는 아래와 같다.

  - (1) 주문 서비스: 주문을 `APPROVAL_PENDING` 상태로 생성 => _주문 생성_ 이벤트 발행
  - (2) 소비자 서비스: _주문 생성_ 이벤트 수신 => 소비자가 주문 가능한지 확인 =>  
    _소비자 확인_ 이벤트 발행
  - (3) 주방 서비스: _주문 생성_ 이벤트 수신 => 주문 내역 확인 => 티켓을 `CREATE_PENDING`  
    상태로 생성 => _티켓 생성됨_ 이벤트 발행
  - (4) 회계 서비스: _주문 생성_ 이벤트 수신 => 신용카드 승인을 `PENDING` 상태로 생성
  - (5) 회계 서비스: _티켓 생성됨_ 및 _소비자 확인_ 이벤트 수신 => 소비자 신용카드 과금 =>  
    _신용카드 승인 실패_ 이벤트 발행
  - (6) 주방 서비스: _신용카드 승인 실패_ 이벤트 수신 => 티켓 상태를 `REJECTED`로 변경
  - (7) 주문 서비스: _신용카드 승인 실패_ 이벤트 수신 => 주문 상태를 `REJECTED`로 변경

- 위 과정에서 알 수 있듯이 코레오크래피 saga 참여자는 발행/구독 방식으로 소통한다.  
  그런데 Saga에서 발행/구독 방식으로 통신하면 어떤 문제점이 있을까?

<h3>확실한 이벤트 기반 통신</h3>

- 코레오그래피 방식으로 Saga를 구현하려면 두 가지 통신 이슈를 고려해야 한다.  
  첫째, **Saga 참여자가 자신의 DB를 업데이트하고, DB 트랜잭션의 일부로 이벤트를 발행** 해야 한다.  
  코레오그래피 saga는 단계별로 DB를 업데이트한 후 이벤트를 발행한다. 가령, 주문 생성 saga에서  
  주방 서비스는 _주문 생성_ 이벤트를 받아 티켓을 생성한 후 _티켓 생성_ 이벤트를 발행한다.  
  여기서 DB를 업데이트하는 작업과 이벤트를 발행하는 작업은 원자적으로 일어나야 한다.  
  따라서 saga 참여자가 서로 확실하게 통신하려면 **트랜잭셔널 메시징**을 사용해야 한다.

- 둘째, **saga 참여자는 자신이 수신한 이벤트와 가진 데이터를 연관지을 수 있어야 한다.**  
  가령 _신용카드 승인됨_ 이벤트를 받은 주문 서비스는 여기에 해당하는 주문을 찾을 수 있어야 한다.  
  해결책은 데이터를 매핑할 수 있도록 다른 saga 참여자가 상관관계 ID가 포함된  
  이벤트를 발행하는 것이다.

- 이를테면 주문 생성 saga에서 각 참여자가 `orderId`를 상관관계 ID로 삼아 다른 참여자에게  
  건네주면 된다. _신용카드 승인됨_ 이벤트를 받은 주문 서비스는 `orderId`로 주문 정보를  
  받아올 수 있고, 주방 서비스도 같은 방법으로 티켓 정보를 가져올 수 있을 것이다.

<h3>코레오그래피 saga의 장단점</h3>

- 코레오그래피 saga는 아래와 같은 장점들이 있다.

  - **단순함** : 비즈니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행한다.
  - **느슨한 결합** : 참여자는 이벤트를 구독할 뿐, 서로를 직접 알지 못한다.

- 하지만 아래와 같은 단점들도 있다.

  - **이해하기 어렵다** : 오케스트레이션 saga와 달리, saga를 어느 한 곳에 정의한 것이  
    아니라서 여러 서비스에 구현 로직이 흩어져 있다. 어떤 saga가 어떻게 작동되는지 개발자가  
    이해하기 어려운 편이다.
  - **서비스 간 순환 의존성** : 참여자가 서로 이벤트를 구독하는 특성상, *순환 의존성*이  
    발생하기 쉽다. 주문 생성 Saga 과정만 보더라도 주문 서비스 => 회계 서비스 => 주문 서비스로  
    순환 의존성이 형성되어 있다. 이것이 반드시 문제라고 할 수는 없지만, 순환 의존성은  
    잠재적인 설계 취약점이다.
  - **단단히 결합될 위험성** : Saga 참여자는 각자 자신에게 영향을 미치는 이벤트를 모두 구독해야 한다.  
    이를테면 회계 서비스는 소비자 신용카드를 과금/환불 처리하게 만드는 모든 이벤트를 구독해야 한다.  
    따라서 이 서비스는 주문 서비스에 구현된 주문 주기와 맞물려 업데이트되어야 하는 위험성이 있다.

- 간단한 saga라면 코레오그래피 방식으로도 충분하지만, 복잡한 saga는 아무래도  
  오케스트레이션 방식이 적합하다.

<hr/>

<h2>오케스트레이션 saga</h2>

- 오케스트레이션 saga에서는 Saga 참여자가 할 일을 알려주는 오케스트레이터 클래스  
  (Orchestrator Class)를 정의한다. Saga 오케스트레이터는 커맨드/비동기 응답  
  상호 작용을 하며 참여자와 통신한다. 즉, Saga 단계를 실행하기 위해 해당 참여자가  
  어떤 일을 해야하는지 커맨드 메시지에 적어 보낸다. Saga 참여자가 작업을 마치고  
  응답 메시지를 오케스트레이터에게 주면, 오케스트레이터는 응답 메시지를 처리한 후  
  다음 Saga 단계를 어느 참여자가 수행할지 결정한다.

<h3>주문 생성 Saga 구현: 오케스트레이션 스타일</h3>

- 오케스트레이션 스타일로 주문 생성 Saga를 설계해보자.  
  Saga 오케스트레이터인 `CreateOrderSaga` 클래스가 비동기 요청/응답을 주고받으면서  
  주방 서비스, 소비자 서비스 같은 Saga 참여자를 호출하고 그 처리 과정에 따라  
  커맨드 메시지를 전송한다. 그리고 이 클래스는 자신의 응답 채널에서 메시지를 읽어  
  다음 Saga 단계를 결정한다.

- 주문 서비스는 먼저 주문 및 주문 생성 Saga 오케스트레이터를 생성한다.  
  이후 별 문제가 없다면 아래와 같이 진행될 것이다.

  - (1): Saga 오케스트레이터가 _소비자 확인_ 커맨드를 소비자 서비스에 전송한다.
  - (2): 소비자 서비스는 _소비자 확인_ 메시지에 응답한다.
  - (3): Saga 오케스트레이터는 _티켓 생성_ 커맨드를 주방 서비스에게 전송한다.
  - (4): 주방 서비스는 _티켓 생성_ 메시지에 응답한다.
  - (5): Saga 오케스트레이터는 _신용카드 승인_ 커맨드를 서비스에게 전송한다.
  - (6): 회계 서비스는 _신용카드 승인됨_ 메시지를 응답한다.
  - (7): Saga 오케스트레이터는 _티켓 승인_ 커맨드를 주방 서비스에 전송한다.
  - (8): Saga 오케스트레이터는 _주문 승인_ 커맨드를 주문 서비스에 전송한다.

- 가장 마지막 단계에서 Saga 오케스트레이터는 자신도 주문 서비스의 한 컴포넌트이지만,  
  커맨드 메시지를 주문 서비스에 전송한다. 물론 주문 생성 Saga가 주문을 직접 업데이트해서  
  승인 처리해도 되지만, 일관성 차원에서 주문 서비스가 마치 다른 참여자인 것처럼  
  취급하는 것이다.

- 위 시나리오는 다양한 Saga 시나리오 중 하나에 불과하다. 주문 생성 Saga의 경우  
  크게 4가지 시나리오를 생각해볼 수 있을 것이다. 방금 본 정상 케이스 외에 소비자 서비스,  
  주방 서비스, 회계 서비스 중 한 곳에 오류가 발생하여 Saga가 실패하는 경우가 3개 더  
  있을 것이다. 그래서 **모든 시나리오를 기술하는 상태 기계로 Saga를 모델링하면 유용하다.**

<h3>Saga 오케스트레이터를 상태 기계로 모델링</h3>

- 상태 기계(State Machine)는 상태(state)와 이벤트에 의해 트리거되는 상태 전이(transition)으로  
  구성된다. 전이가 발생할 때마다 액션(action)이 일어나는데, Saga의 액션은 Saga 참여자를  
  호출하는 작용이다. 상태 간 전이는 Saga 참여자가 로컬 트랜잭션을 완료하는 시점에 트리거되고,  
  로컬 트랜잭션의 상태와 결과에 따라 상태 전이를 어떻게 하고 어떤 액션을 취할지가 결정된다.  
  상태 기계는 효율적으로 테스트할 수 있기 때문에 상태 기계를 이용하여 Saga를 모델링하면  
  설계, 구현, 테스트를 더 쉽게 진행할 수 있다.

- 주문 생성 saga를 상태 기계로 모델링 해보자.  
  이 상태 기계를 구성한 상태들은 아래와 같다.

  - **소비자 확인**: 초기 상태, Saga는 소비자 서비스가 주문 가능한 소비자인지 확인할 때까지 기다린다.
  - **티켓 생성**: Saga는 _티켓 생성_ 커맨드에 대한 응답을 기다린다.
  - **신용카드 승인**: 회계 서비스가 소비자 신용카드를 승인할 때까지 기다린다.
  - **주문 승인됨**: Saga가 성공적으로 완료되었음을 나타내는 최종 상태
  - **주문 거부됨**: 참여자 중 하나가 주문을 거부했음을 나타내는 최종 상태

- 상태 기계는 다양한 상태 전이도 정의한다. 가령 주문 생성 Saga의 상태 기계는  
  **티켓 생성 상태** => **신용카드 승인 또는 주문 거부됨 상태**로 전이한다.  
  _티켓 생성_ 커맨드를 보내 성공 응답을 받으면 **신용카드 승인 상태**, 주방 서비스가  
  티켓 생성을 할 수 없으면 **주문 거부 상태**로 전이될 것이다.

- 상태 기계의 초기 액션은 소비자 서비스에 _소비자 확인_ 커맨드를 전송하는 것이다.  
  소비자 서비스의 이 커맨드에 대한 응답에 따라 그 다음 전이가 트리거될 것이다.  
  소비자 확인에 문제가 없으면 Saga는 티켓을 만들어 **티켓 생성 상태**로 전이하지만,  
  그 외에는 주문을 거부하고 **주문 거부 상태**로 전이한다. 상태 기계는 Saga 참여자의  
  여러 가지 응답에 따라 다양한 상태 전이를 거치면서 결국 **주문 승인됨 상태** 또는  
  **주문 거부됨 상태** 두 상태 중 한쪽으로 귀결된다.

<h3>Saga 오케스트레이션과 트랜잭셔널 메시징</h3>

- 오케스트레이션 Saga는 DB를 업데이트하는 서비스와 메시지를 발행하는 서비스가 단계마다 있다.  
  예를 들어, 주문 서비스는 주문 및 주문 생성 Saga 오케스트레이터를 생성한 후 1번 Saga  
  참여자에게 메시지를 보낸다. Saga 참여자는 자신의 DB를 업데이트한 후 응답 메시지를  
  보내는 식으로 커맨드 메시지를 처리한다. 그러면 다시 주문 서비스는 Saga 오케스트레이터의  
  상태를 업데이트한 후 커맨드 메시지를 다음 Saga 참여자에게 보낸다. 이런 식으로 참여자의  
  응답 서비스를 처리하는 것이다. 이때 서비스는 트랜잭셔널 메시징을 사용해서 DB 업데이트와  
  메시지 발행 작업을 원자적으로 처리해야 한다. 주문 생성 Saga의 오케스트레이터 구현 및  
  메시징 적용 방법은 뒤에서 본다.

<h3>오케스트레이션 Saga의 장단점</h3>

- 오케스트레이션 Saga는 아래의 장점들이 있다.

  - **의존 관계 단순화**: 오케스트레이터는 참여자를 호출하지만, 참여자는 오케스트레이터를  
    호출하지 않으므로 순환 의존성이 발생하지 않는다. 즉, 오케스트레이터는 참여자에게 의존하지만  
    그 반대는 성립되지 않으므로 순환 의존성은 발생하지 않는다.
  - **낮은 결합도**: 각 서비스는 오케스트레이터가 호출하는 API를 구현할 뿐, Saga 참여자가  
    발행하는 이벤트는 몰라도 된다.
  - **관심사를 더 분리하고 비즈니스 로직을 단순화**: Saga 편성 로직이 Saga 오케스트레이터  
    한 곳에만 있으므로 도메인 객체는 더 단순해지고, 자신이 참여한 Saga에 대해서는 알지 못한다.  
    가령 `Order` 클래스는 Saga를 모르기 때문에 상태 기계 모델은 더욱 간단해져서  
    주문 생성 Saga 실행 도중 `APPROVAL_PENDING` => `APPROVED`로 바로 상태 전이가 된다.  
    또 이 클래스는 saga 단계에 대응되는 중간 상태가 하나도 없으므로 비즈니스 로직은 훨씬  
    단순해진다.

- 오케스트레이션 스타일도 단점은 있다. 비즈니스 로직을 오케스트레이터에 너무 많이 중앙화하면  
  똑똑한 오케스트레이터 하나가 깡통 서비스에 일일이 할 일을 지시하는 모양새가 될 수 있다.  
  이 문제는 오케스트레이터가 순서화만 담당하고, 여타 비즈니스 로직은 갖지 않도록 설계하면 해결된다.

- 아주 단순한 Saga가 아니라면 저자는 오케스트레이션 방식을 권장한다.  
  그런데 Saga를 이용할 때 편성 로직보다 더 골치 아픈 이슈가 있는데, 바로 **비격리 문제**이다.  
  격리가 안되면 트랜잭션을 어떻게 처리해야 할까?

<hr/>
