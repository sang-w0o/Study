# 개략적인 규모 추정

- 시스템 용량이나 성능 요구사항을 개략적으로 추정해야 할 때가 있다.  
  개략적인 규모 추정의 정의 중 하나를 보자.

- **개략적인 규모 추정(back-of-the-envelope estimation)** : 보편적으로 통용되는 성능 수치상에서  
  사고 실험을 행하여 추정치를 계산하는 행위로서, 어떤 설계가 요구사항에 부합하는지 보기 위한 것

## 2의 제곱수

- 분산 시스템에서 다루는 데이터량은 엄청나게 커질 수 있으나 그 계산법은 기본을 크게 벗어나지 않는다.  
  제대로 된 계산 결과를 얻으려면 데이터 볼륨의 단위를 2의 제곱수로 표현하면 어떻게 되는지를 우선 알아야 한다.  
  최소 단위는 1바이트(8비트)이다. ASCII 문자 하나가 차지하는 메모리 크기가 1바이트이다.  
  아래 표는 흔히 쓰이는 데이터 볼륨 단위이다.

| 2의 제곱수 | 근사치              | 이름       | 축약형 |
| ---------- | ------------------- | ---------- | ------ |
| 10         | 1천(thousand)       | 1 Kilobyte | 1KB    |
| 20         | 1백만(million)      | 1 Megabyte | 1MB    |
| 30         | 10억(billion)       | 1 Gigabyte | 1GB    |
| 40         | 1조(trillion)       | 1 Terabyte | 1TB    |
| 50         | 1000조(quadrillion) | 1 Petabyte | 1PB    |

<hr/>

## 모든 프로그래머가 알아야하는 latency(응답 지연) 값

- 2010년에 공개된 통상적인 컴퓨터에서 구현된 연산들의 응답지연 값을 보자. 이들 가운데 몇몇은 더 빠른 컴퓨터의 등장으로  
  더 이상 유효하지 않게 되었지만, 아직도 이 수치들은 컴퓨터 연산들의 처리 속도가 어느 정도인지 짐작할 수 있게 해준다.

| 연산명                                              | 시간                  |
| --------------------------------------------------- | --------------------- |
| L1 cache 참조                                       | 0.5ns                 |
| 분기 예측 오류(branch mispredict)                   | 5ns                   |
| L2 cache 참조                                       | 7ns                   |
| mutax lock/unlock                                   | 100ns                 |
| 주 메모리 참조                                      | 100ns                 |
| Zippy로 1KB 압축                                    | 10,000ns = 10µs       |
| 1Gbps 네트워크로 2KB 전송                           | 20,000ns = 20µs       |
| 메모리에서 1MB 순차적으로 read                      | 250,000ns = 250µs     |
| 같은 데이터 센터 내에서의 메시지 왕복 지연시간      | 500,000ns = 500µs     |
| 디스크 탐색(seek)                                   | 10,000,000ns = 10ms   |
| 네트워크에서 1MB 순차적으로 read                    | 10,000,000ns = 10ms   |
| 디스크에서 1MB 순차적으로 read                      | 30,000,000ns = 30ms   |
| 한 패킷의 캘리포니아로부터 네덜란드까지의 왕복 시간 | 150,000,000ns = 150ms |

> ns: Nanosecond(10^-9s), µs: Microsecond(10^-6s), ms: Millisecond(10^-3s)

- 위 수치들을 분석하면, 아래와 같은 결론이 나온다.

  - 메모리는 빠르지만 디스크는 아직도 느리다.
  - 디스크 탐색(seek)은 가증한 한 피하라.
  - 단순한 압축 알고리즘은 빠르다.
  - 데이터를 인터넷으로 전송하기 전에 가능하면 압축하라.
  - 데이터 센터는 보통 여러 지역(region)에 분산되어 있고, 센터들 간에 데이터를 주고받는 데는 시간이 걸린다.

<hr/>

## 가용성에 관계된 수치들

- 고가용성(High Availability)은 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력을 지칭하는 용어다.  
  고가용성을 표현하는 값은 퍼센트로 표현하는데, 100%는 시스템이 단 한 번도 중단된 적이 없었음을 의미한다.  
  대부분의 서비스는 99%에서 100% 사이의 값을 갖는다.

- SLA(Service Level Agreement)는 서비스 사업자(Service Provider)가 보편적으로 사용하는 용어로, 서비스 사업자와  
  고객 사이에 맺어진 합의를 의미한다. 이 합의에는 서비스 사업자가 제공하는 서비스의 가용시간(uptime)이 공식적으로  
  기술되어 있다. Amazon, Google, Microsoft 같은 사업자는 99% 이상의 SLA를 제공한다. 가용 시간은 관습적으로 숫자 9를  
  사용해 표시한다.

> 9가 많으면 많을 수록 좋다고 보면 된다.

- 아래 표는 9의 개수와 시스템 장애 시간(downtime) 사이의 관계다.

|  가용률  | 하루당 장애시간 | 주당 장애시간 | 개월당 장애시간 | 연간 장애시간 |
| :------: | :-------------: | :-----------: | :-------------: | :-----------: |
|   99%    |     14.40분     |   1.68시간    |    7.31시간     |    3.65일     |
|  99.9%   |     1.44분      |    10.08분    |     43.83분     |   8.77시간    |
|  99.99%  |     8.64초      |    1.01분     |     4.38분      |    52.60분    |
| 99.999%  |    864.00ms     |    6.05초     |     26.30초     |    5.26분     |
| 99.9999% |     86.40ms     |   604.80ms    |     2.63초      |    31.56초    |

<hr/>

## 예제: twitter의 QPS와 저장소 요구량 추정

- 아래 제시된 연습용 수치들을 이용해 QPS와 저장소 요구량을 추정해보자.

### 가정

- MAU는 약 3억 명이다.
- 50%의 사용자가 twitter를 매일 사용한다.
- 평균적으로 각 사용자는 매일 2건의 tweet을 올린다.
- 미디어를 포함하는 tweet은 10% 정도다.
- 데이터는 5년간 보관된다.

### 추정

#### QPS(Query Per Second) 추정치

- DAU = 3억 \* 50% = 1.5억
- QPS = 1.5억 \* 2 tweet / 24hr / 3600s = 약 3500
- 최대 QPS(Peek QPS) = 2 \* QPS = 약 7000

#### 미디어 저장을 위한 저장소 요구량

- 평균 tweet 크기
  - tweet_id에 64바이트
  - 텍스트에 140바이트
  - 미디어에 1MB
- 미디어 저장소 요구량: 1.5억 \* 2 \* 10% \* 1MB = 30TB/일
- 5년간 미디어를 보관하기 위한 저장소 요구량: 30TB \* 365 \* 5 = 약 55PB

<hr/>
